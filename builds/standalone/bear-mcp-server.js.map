{
  "version": 3,
  "sources": ["../../node_modules/zod/dist/esm/v3/external.js", "../../node_modules/zod/dist/esm/v3/helpers/util.js", "../../node_modules/zod/dist/esm/v3/ZodError.js", "../../node_modules/zod/dist/esm/v3/locales/en.js", "../../node_modules/zod/dist/esm/v3/errors.js", "../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js", "../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js", "../../node_modules/zod/dist/esm/v3/types.js", "../../node_modules/@modelcontextprotocol/sdk/src/types.ts", "../../node_modules/@modelcontextprotocol/sdk/src/shared/protocol.ts", "../../node_modules/@modelcontextprotocol/sdk/src/server/index.ts", "../../node_modules/@modelcontextprotocol/sdk/src/server/stdio.ts", "../../node_modules/@modelcontextprotocol/sdk/src/shared/stdio.ts", "../../src/utils/database.ts", "../../src/types/bear.ts", "../../src/services/bear-service.ts", "../../src/index.ts"],
  "sourcesContent": ["export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n", null, null, null, null, null, "import sqlite3 from 'sqlite3';\nimport { promisify } from 'util';\nimport { access, constants, copyFile, stat, mkdir } from 'fs/promises';\nimport { exec } from 'child_process';\nimport path from 'path';\nimport os from 'os';\nimport { BearDatabaseError, BearSafetyError } from '../types/bear.js';\n\nconst execAsync = promisify(exec);\n\n/**\n * Database connection and safety utilities for Bear SQLite integration\n */\nexport class BearDatabase {\n  private db: sqlite3.Database | null = null;\n  private readonly dbPath: string;\n  private readonly backupDir: string;\n\n  constructor(dbPath?: string) {\n    // Default to standard Bear database location on macOS\n    this.dbPath =\n      dbPath ||\n      path.join(\n        os.homedir(),\n        'Library/Group Containers/9K33E3U3T4.net.shinyfrog.bear/Application Data/database.sqlite'\n      );\n    // Use user's Documents directory for backups - much more accessible\n    this.backupDir = path.join(os.homedir(), 'Documents', 'Bear MCP Backups');\n  }\n\n  /**\n   * Check if Bear app is currently running\n   * Critical safety check to prevent database corruption\n   */\n  async isBearRunning(): Promise<boolean> {\n    try {\n      // Use AppleScript to check if Bear is running - more reliable on macOS\n      const { stdout } = await execAsync(\n        'osascript -e \\'tell application \"System Events\" to get name of every process whose name is \"Bear\"\\''\n      );\n\n      // If AppleScript returns \"Bear\", the app is running\n      const isRunning = stdout.trim().includes('Bear');\n\n      return isRunning;\n    } catch (error) {\n      // If AppleScript fails, fall back to process check\n      try {\n        const { stdout } = await execAsync('pgrep -x \"Bear\"');\n        return stdout.trim().length > 0;\n      } catch (fallbackError) {\n        // If both methods fail, assume Bear might be running (safer approach)\n        return false; // Changed: if we can't detect it, assume it's not running rather than blocking everything\n      }\n    }\n  }\n\n  /**\n   * Verify database file exists and is accessible\n   */\n  async verifyDatabaseAccess(): Promise<void> {\n    try {\n      await access(this.dbPath, constants.R_OK | constants.W_OK);\n      const stats = await stat(this.dbPath);\n\n      if (stats.size === 0) {\n        throw new BearDatabaseError('Database file is empty');\n      }\n\n      // Database verified successfully\n    } catch (error) {\n      throw new BearDatabaseError(\n        `Cannot access Bear database at ${this.dbPath}: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Create a timestamped backup of the database\n   */\n  async createBackup(): Promise<string> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupPath = path.join(this.backupDir, `bear_backup_${timestamp}.sqlite`);\n\n    try {\n      // Ensure backup directory exists\n      await mkdir(this.backupDir, { recursive: true });\n\n      // Copy database file\n      await copyFile(this.dbPath, backupPath);\n\n      const stats = await stat(backupPath);\n      // Backup created successfully\n\n      return backupPath;\n    } catch (error) {\n      throw new BearDatabaseError(\n        `Failed to create backup: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Perform comprehensive safety checks before database operations\n   */\n  async performSafetyChecks(requireWriteAccess: boolean = false): Promise<void> {\n    // Only check if Bear is running for direct database write operations\n    // Note: Modern write operations use sync-safe Bear API, so this check is rarely triggered\n    if (requireWriteAccess && (await this.isBearRunning())) {\n      throw new BearSafetyError(\n        'Direct database writes are not allowed while Bear is running. Use sync-safe Bear API instead.'\n      );\n    }\n\n    // Verify database access\n    await this.verifyDatabaseAccess();\n\n    // Create backup for write operations\n    if (requireWriteAccess) {\n      await this.createBackup();\n      // Safety checks passed for write operation\n    } else {\n      // Safety checks passed for read-only operation\n    }\n  }\n\n  /**\n   * Connect to the database with safety checks\n   */\n  async connect(readOnly: boolean = true): Promise<void> {\n    if (this.db) {\n      return; // Already connected\n    }\n\n    await this.performSafetyChecks(!readOnly);\n\n    return new Promise((resolve, reject) => {\n      const mode = readOnly ? sqlite3.OPEN_READONLY : sqlite3.OPEN_READWRITE;\n\n      this.db = new sqlite3.Database(this.dbPath, mode, err => {\n        if (err) {\n          reject(new BearDatabaseError(`Failed to connect to database: ${err.message}`));\n        } else {\n          // Connected to Bear database\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Disconnect from the database\n   */\n  async disconnect(): Promise<void> {\n    if (!this.db) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db!.close(err => {\n        if (err) {\n          reject(new BearDatabaseError(`Failed to close database: ${err.message}`));\n        } else {\n          // Disconnected from Bear database\n          this.db = null;\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Execute a SELECT query\n   */\n  async query<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n    if (!this.db) {\n      throw new BearDatabaseError('Database not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db!.all(sql, params, (err, rows) => {\n        if (err) {\n          reject(new BearDatabaseError(`Query failed: ${err.message}\\nSQL: ${sql}`));\n        } else {\n          resolve(rows as T[]);\n        }\n      });\n    });\n  }\n\n  /**\n   * Execute a single SELECT query that returns one row\n   */\n  async queryOne<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n    if (!this.db) {\n      throw new BearDatabaseError('Database not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db!.get(sql, params, (err, row) => {\n        if (err) {\n          reject(new BearDatabaseError(`Query failed: ${err.message}\\nSQL: ${sql}`));\n        } else {\n          resolve((row as T) || null);\n        }\n      });\n    });\n  }\n\n  /**\n   * Execute an INSERT, UPDATE, or DELETE query\n   */\n  async execute(sql: string, params: any[] = []): Promise<{ changes: number; lastID: number }> {\n    if (!this.db) {\n      throw new BearDatabaseError('Database not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db!.run(sql, params, function (err) {\n        if (err) {\n          reject(new BearDatabaseError(`Execute failed: ${err.message}\\nSQL: ${sql}`));\n        } else {\n          resolve({ changes: this.changes, lastID: this.lastID });\n        }\n      });\n    });\n  }\n\n  /**\n   * Begin a transaction\n   */\n  async beginTransaction(): Promise<void> {\n    await this.execute('BEGIN TRANSACTION');\n  }\n\n  /**\n   * Commit a transaction\n   */\n  async commitTransaction(): Promise<void> {\n    await this.execute('COMMIT');\n  }\n\n  /**\n   * Rollback a transaction\n   */\n  async rollbackTransaction(): Promise<void> {\n    await this.execute('ROLLBACK');\n  }\n\n  /**\n   * Execute multiple operations in a transaction\n   */\n  async transaction<T>(operations: () => Promise<T>): Promise<T> {\n    await this.beginTransaction();\n\n    try {\n      const result = await operations();\n      await this.commitTransaction();\n      return result;\n    } catch (error) {\n      await this.rollbackTransaction();\n      throw error;\n    }\n  }\n\n  /**\n   * Get database schema information\n   */\n  async getSchema(): Promise<{ name: string; sql: string }[]> {\n    return this.query(`\n      SELECT name, sql \n      FROM sqlite_master \n      WHERE type = 'table' \n      ORDER BY name\n    `);\n  }\n\n  /**\n   * Check database integrity\n   */\n  async checkIntegrity(): Promise<boolean> {\n    const result = await this.queryOne<{ integrity_check: string }>('PRAGMA integrity_check');\n    return result?.integrity_check === 'ok';\n  }\n}\n\n/**\n * Core Data timestamp utilities\n * Core Data uses seconds since 2001-01-01 00:00:00 UTC\n */\nexport class CoreDataUtils {\n  // Core Data epoch: January 1, 2001 00:00:00 UTC\n  private static readonly CORE_DATA_EPOCH = new Date('2001-01-01T00:00:00Z').getTime();\n\n  /**\n   * Convert Core Data timestamp to JavaScript Date\n   */\n  static toDate(coreDataTimestamp: number): Date {\n    return new Date(this.CORE_DATA_EPOCH + coreDataTimestamp * 1000);\n  }\n\n  /**\n   * Convert JavaScript Date to Core Data timestamp\n   */\n  static fromDate(date: Date): number {\n    return (date.getTime() - this.CORE_DATA_EPOCH) / 1000;\n  }\n\n  /**\n   * Get current timestamp in Core Data format\n   */\n  static now(): number {\n    return this.fromDate(new Date());\n  }\n}\n", "/**\n * TypeScript interfaces for Bear's SQLite database entities\n * Based on Core Data schema with Z-prefixed table names\n */\n\nexport interface BearNote {\n  Z_PK: number; // Primary key\n  ZTITLE: string | null; // Note title\n  ZTEXT: string | null; // Note content (markdown)\n  ZCREATIONDATE: number; // Creation timestamp (Core Data format)\n  ZMODIFICATIONDATE: number; // Last modified timestamp\n  ZTRASHED: number; // Trash status (0=active, 1=trashed)\n  ZARCHIVED: number; // Archive status (0=not archived, 1=archived)\n  ZPINNED: number; // Pinned status (0=not pinned, 1=pinned)\n  ZENCRYPTED: number; // Encryption status (0=not encrypted, 1=encrypted)\n  ZORDER: number | null; // Display order\n  ZTRASHEDDATE: number | null; // Date when trashed\n  ZARCHIVEDDATE: number | null; // Date when archived\n}\n\nexport interface BearTag {\n  Z_PK: number; // Primary key\n  ZTITLE: string; // Tag name\n  ZPARENT: number | null; // Parent tag reference (for hierarchical tags)\n  ZORDER: number | null; // Display order\n  ZCREATIONDATE: number; // Creation timestamp\n  ZMODIFICATIONDATE: number; // Last modified timestamp\n}\n\nexport interface BearNoteTag {\n  ZNOTES: number; // Foreign key to ZSFNOTE.Z_PK\n  ZTAGS: number; // Foreign key to ZSFTAG.Z_PK\n}\n\nexport interface BearNoteSearch {\n  Z_PK: number; // Primary key\n  ZNOTE: number; // Foreign key to ZSFNOTE.Z_PK\n  ZTITLE: string | null; // Indexed title for search\n  ZTEXT: string | null; // Indexed content for search\n}\n\nexport interface BearNoteFile {\n  Z_PK: number; // Primary key\n  ZNOTE: number; // Foreign key to ZSFNOTE.Z_PK\n  ZFILENAME: string; // Original filename\n  ZFILESIZE: number; // File size in bytes\n  ZFILETYPE: string | null; // MIME type\n  ZFILEURL: string; // File path/URL\n  ZCREATIONDATE: number; // Creation timestamp\n}\n\n// Utility types for API responses\nexport interface NoteWithTags extends BearNote {\n  tags: string[]; // Array of tag names\n  contentLength?: number; // Content length in characters\n  preview?: string; // Content preview (first 200 chars or encrypted indicator)\n}\n\nexport interface TagWithCount extends BearTag {\n  noteCount: number; // Number of notes with this tag\n}\n\nexport interface DatabaseStats {\n  totalNotes: number;\n  activeNotes: number;\n  trashedNotes: number;\n  archivedNotes: number;\n  encryptedNotes: number;\n  totalTags: number;\n  totalAttachments: number;\n  databaseSize: number; // Size in bytes\n  lastModified: Date;\n}\n\n// Search and filter types\nexport interface NoteSearchOptions {\n  query?: string; // Text search query\n  tags?: string[]; // Filter by tags\n  dateFrom?: Date; // Filter by creation date range\n  dateTo?: Date;\n  includeArchived?: boolean; // Include archived notes\n  includeTrashed?: boolean; // Include trashed notes\n  limit?: number; // Limit results\n  offset?: number; // Pagination offset\n}\n\nexport interface NoteCreateOptions {\n  title?: string;\n  content: string;\n  tags?: string[];\n  pinned?: boolean;\n  archived?: boolean;\n}\n\nexport interface NoteUpdateOptions {\n  title?: string;\n  content?: string;\n  tags?: string[];\n  pinned?: boolean;\n  archived?: boolean;\n  trashed?: boolean;\n}\n\n// Core Data timestamp conversion utilities\nexport interface CoreDataTimestamp {\n  timestamp: number; // Core Data timestamp (seconds since 2001-01-01)\n  date: Date; // JavaScript Date object\n}\n\n// Error types\nexport class BearDatabaseError extends Error {\n  constructor(\n    message: string,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'BearDatabaseError';\n  }\n}\n\nexport class BearSafetyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'BearSafetyError';\n  }\n}\n", "/**\n * Bear MCP Server - Bear Service\n * Copyright (c) 2024 Bear MCP Server\n * MIT License - see LICENSE file for details\n */\n\nimport { BearDatabase, CoreDataUtils } from '../utils/database.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  BearNote,\n  BearTag,\n  BearNoteTag,\n  NoteWithTags,\n  TagWithCount,\n  DatabaseStats,\n  NoteSearchOptions,\n  BearDatabaseError,\n  BearSafetyError,\n} from '../types/bear.js';\n\n/**\n * Service layer for Bear database operations\n * Provides high-level methods for interacting with Bear's data\n */\nexport class BearService {\n  private database: BearDatabase;\n\n  constructor(dbPath?: string) {\n    this.database = new BearDatabase(dbPath);\n  }\n\n  /**\n   * Get comprehensive database statistics\n   */\n  async getDatabaseStats(): Promise<DatabaseStats> {\n    await this.database.connect(true); // Read-only connection\n\n    try {\n      const [\n        totalNotes,\n        activeNotes,\n        trashedNotes,\n        archivedNotes,\n        encryptedNotes,\n        totalTags,\n        totalAttachments,\n      ] = await Promise.all([\n        this.database.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM ZSFNOTE'),\n        this.database.queryOne<{ count: number }>(\n          'SELECT COUNT(*) as count FROM ZSFNOTE WHERE ZTRASHED = 0'\n        ),\n        this.database.queryOne<{ count: number }>(\n          'SELECT COUNT(*) as count FROM ZSFNOTE WHERE ZTRASHED = 1'\n        ),\n        this.database.queryOne<{ count: number }>(\n          'SELECT COUNT(*) as count FROM ZSFNOTE WHERE ZARCHIVED = 1'\n        ),\n        this.database.queryOne<{ count: number }>(\n          'SELECT COUNT(*) as count FROM ZSFNOTE WHERE ZENCRYPTED = 1'\n        ),\n        this.database.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM ZSFNOTETAG'),\n        this.database.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM ZSFNOTEFILE'),\n      ]);\n\n      // Get database file size and last modified date\n      const fs = await import('fs/promises');\n      const stats = await fs.stat(this.database['dbPath']);\n\n      return {\n        totalNotes: totalNotes?.count || 0,\n        activeNotes: activeNotes?.count || 0,\n        trashedNotes: trashedNotes?.count || 0,\n        archivedNotes: archivedNotes?.count || 0,\n        encryptedNotes: encryptedNotes?.count || 0,\n        totalTags: totalTags?.count || 0,\n        totalAttachments: totalAttachments?.count || 0,\n        databaseSize: stats.size,\n        lastModified: stats.mtime,\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get all notes with optional filtering\n   */\n  async getNotes(options: NoteSearchOptions = {}): Promise<NoteWithTags[]> {\n    await this.database.connect(true);\n\n    try {\n      let sql = `\n        SELECT n.*, GROUP_CONCAT(t.ZTITLE) as tag_names\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE 1=1\n      `;\n\n      const params: any[] = [];\n\n      // Apply filters\n      if (!options.includeTrashed) {\n        sql += ' AND n.ZTRASHED = 0';\n      }\n\n      if (!options.includeArchived) {\n        sql += ' AND n.ZARCHIVED = 0';\n      }\n\n      if (options.query) {\n        sql += ' AND (n.ZTITLE LIKE ? OR n.ZTEXT LIKE ?)';\n        const searchTerm = `%${options.query}%`;\n        params.push(searchTerm, searchTerm);\n      }\n\n      if (options.dateFrom) {\n        sql += ' AND n.ZCREATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(options.dateFrom));\n      }\n\n      if (options.dateTo) {\n        sql += ' AND n.ZCREATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(options.dateTo));\n      }\n\n      sql += ' GROUP BY n.Z_PK ORDER BY n.ZMODIFICATIONDATE DESC';\n\n      if (options.limit) {\n        sql += ' LIMIT ?';\n        params.push(options.limit);\n\n        if (options.offset) {\n          sql += ' OFFSET ?';\n          params.push(options.offset);\n        }\n      }\n\n      const rows = await this.database.query<BearNote & { tag_names: string }>(sql, params);\n\n      return rows.map(row => ({\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n      }));\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get a single note by ID\n   */\n  async getNoteById(id: number): Promise<NoteWithTags | null> {\n    await this.database.connect(true);\n\n    try {\n      const sql = `\n        SELECT n.*, GROUP_CONCAT(t.ZTITLE) as tag_names\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE n.Z_PK = ?\n        GROUP BY n.Z_PK\n      `;\n\n      const row = await this.database.queryOne<BearNote & { tag_names: string }>(sql, [id]);\n\n      if (!row) {\n        return null;\n      }\n\n      return {\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get a single note by title\n   */\n  async getNoteByTitle(title: string): Promise<NoteWithTags | null> {\n    await this.database.connect(true);\n\n    try {\n      const sql = `\n        SELECT n.*, GROUP_CONCAT(t.ZTITLE) as tag_names\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE n.ZTITLE = ? AND n.ZTRASHED = 0\n        GROUP BY n.Z_PK\n        LIMIT 1\n      `;\n\n      const row = await this.database.queryOne<BearNote & { tag_names: string }>(sql, [title]);\n\n      if (!row) {\n        return null;\n      }\n\n      return {\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Search notes by content and title\n   */\n  async searchNotes(query: string, options: NoteSearchOptions = {}): Promise<NoteWithTags[]> {\n    return this.getNotes({ ...options, query });\n  }\n\n  /**\n   * Get all tags with usage counts\n   */\n  async getTags(): Promise<TagWithCount[]> {\n    await this.database.connect(true);\n\n    try {\n      const sql = `\n        SELECT t.*, COUNT(nt.Z_5NOTES) as noteCount\n        FROM ZSFNOTETAG t\n        LEFT JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS\n        LEFT JOIN ZSFNOTE n ON nt.Z_5NOTES = n.Z_PK AND n.ZTRASHED = 0\n        GROUP BY t.Z_PK\n        ORDER BY noteCount DESC, t.ZTITLE ASC\n      `;\n\n      return await this.database.query<TagWithCount>(sql);\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get notes by tag\n   */\n  async getNotesByTag(tagName: string): Promise<NoteWithTags[]> {\n    await this.database.connect(true);\n\n    try {\n      const sql = `\n        SELECT n.*, GROUP_CONCAT(t2.ZTITLE) as tag_names\n        FROM ZSFNOTE n\n        JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        LEFT JOIN Z_5TAGS nt2 ON n.Z_PK = nt2.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t2 ON nt2.Z_13TAGS = t2.Z_PK\n        WHERE t.ZTITLE = ? AND n.ZTRASHED = 0\n        GROUP BY n.Z_PK\n        ORDER BY n.ZMODIFICATIONDATE DESC\n      `;\n\n      const rows = await this.database.query<BearNote & { tag_names: string }>(sql, [tagName]);\n\n      return rows.map(row => ({\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n      }));\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Check if Bear app is currently running\n   */\n  async isBearRunning(): Promise<boolean> {\n    return this.database.isBearRunning();\n  }\n\n  /**\n   * Verify database access\n   */\n  async verifyDatabaseAccess(): Promise<void> {\n    await this.database.verifyDatabaseAccess();\n  }\n\n  /**\n   * Create a database backup\n   */\n  async createBackup(): Promise<string> {\n    return this.database.createBackup();\n  }\n\n  /**\n   * Get database schema information\n   */\n  async getSchema(): Promise<{ name: string; sql: string }[]> {\n    await this.database.connect(true);\n\n    try {\n      return this.database.getSchema();\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Check database integrity\n   */\n  async checkIntegrity(): Promise<boolean> {\n    await this.database.connect(true);\n\n    try {\n      return this.database.checkIntegrity();\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get recent notes (last 10 by default)\n   */\n  async getRecentNotes(limit: number = 10): Promise<NoteWithTags[]> {\n    return this.getNotes({ limit, includeArchived: false, includeTrashed: false });\n  }\n\n  /**\n   * Get note count by status\n   */\n  async getNoteCountsByStatus(): Promise<{\n    total: number;\n    active: number;\n    trashed: number;\n    archived: number;\n    encrypted: number;\n  }> {\n    const stats = await this.getDatabaseStats();\n    return {\n      total: stats.totalNotes,\n      active: stats.activeNotes,\n      trashed: stats.trashedNotes,\n      archived: stats.archivedNotes,\n      encrypted: stats.encryptedNotes,\n    };\n  }\n\n  /**\n   * Get notes with advanced filtering options\n   */\n  async getNotesAdvanced(\n    options: {\n      query?: string;\n      tags?: string[];\n      excludeTags?: string[];\n      dateFrom?: Date;\n      dateTo?: Date;\n      modifiedAfter?: Date;\n      modifiedBefore?: Date;\n      includeContent?: boolean;\n      includeTrashed?: boolean;\n      includeArchived?: boolean;\n      includeEncrypted?: boolean;\n      sortBy?: 'created' | 'modified' | 'title' | 'size';\n      sortOrder?: 'asc' | 'desc';\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<NoteWithTags[]> {\n    await this.database.connect(true);\n\n    try {\n      let sql = `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               LENGTH(n.ZTEXT) as content_length,\n               CASE \n                 WHEN n.ZENCRYPTED = 1 THEN '[ENCRYPTED]'\n                 ELSE SUBSTR(n.ZTEXT, 1, 200)\n               END as preview\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE 1=1\n      `;\n\n      const params: any[] = [];\n\n      // Basic filters\n      if (!options.includeTrashed) {\n        sql += ' AND n.ZTRASHED = 0';\n      }\n\n      if (!options.includeArchived) {\n        sql += ' AND n.ZARCHIVED = 0';\n      }\n\n      if (!options.includeEncrypted) {\n        sql += ' AND n.ZENCRYPTED = 0';\n      }\n\n      // Text search\n      if (options.query) {\n        sql += ' AND (n.ZTITLE LIKE ? OR n.ZTEXT LIKE ?)';\n        const searchTerm = `%${options.query}%`;\n        params.push(searchTerm, searchTerm);\n      }\n\n      // Date filters\n      if (options.dateFrom) {\n        sql += ' AND n.ZCREATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(options.dateFrom));\n      }\n\n      if (options.dateTo) {\n        sql += ' AND n.ZCREATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(options.dateTo));\n      }\n\n      if (options.modifiedAfter) {\n        sql += ' AND n.ZMODIFICATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(options.modifiedAfter));\n      }\n\n      if (options.modifiedBefore) {\n        sql += ' AND n.ZMODIFICATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(options.modifiedBefore));\n      }\n\n      sql += ' GROUP BY n.Z_PK';\n\n      // Tag filters (applied after grouping)\n      if (options.tags && options.tags.length > 0) {\n        const tagConditions = options.tags.map(() => 'tag_names LIKE ?').join(' AND ');\n        sql += ` HAVING ${tagConditions}`;\n        options.tags.forEach(tag => params.push(`%${tag}%`));\n      }\n\n      if (options.excludeTags && options.excludeTags.length > 0) {\n        const excludeConditions = options.excludeTags\n          .map(() => 'tag_names NOT LIKE ? OR tag_names IS NULL')\n          .join(' AND ');\n        sql += options.tags ? ` AND (${excludeConditions})` : ` HAVING (${excludeConditions})`;\n        options.excludeTags.forEach(tag => params.push(`%${tag}%`));\n      }\n\n      // Sorting\n      const sortBy = options.sortBy || 'modified';\n      const sortOrder = options.sortOrder || 'desc';\n\n      switch (sortBy) {\n        case 'created':\n          sql += ` ORDER BY n.ZCREATIONDATE ${sortOrder.toUpperCase()}`;\n          break;\n        case 'modified':\n          sql += ` ORDER BY n.ZMODIFICATIONDATE ${sortOrder.toUpperCase()}`;\n          break;\n        case 'title':\n          sql += ` ORDER BY n.ZTITLE ${sortOrder.toUpperCase()}`;\n          break;\n        case 'size':\n          sql += ` ORDER BY LENGTH(n.ZTEXT) ${sortOrder.toUpperCase()}`;\n          break;\n        default:\n          sql += ` ORDER BY n.ZMODIFICATIONDATE DESC`;\n      }\n\n      // Pagination\n      if (options.limit) {\n        sql += ' LIMIT ?';\n        params.push(options.limit);\n\n        if (options.offset) {\n          sql += ' OFFSET ?';\n          params.push(options.offset);\n        }\n      }\n\n      const rows = await this.database.query<\n        BearNote & {\n          tag_names: string;\n          content_length: number;\n          preview: string;\n        }\n      >(sql, params);\n\n      return rows.map(row => ({\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n        contentLength: row.content_length,\n        preview: row.preview,\n      }));\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get notes by multiple criteria with AND/OR logic\n   */\n  async getNotesWithCriteria(criteria: {\n    titleContains?: string[];\n    contentContains?: string[];\n    hasAllTags?: string[];\n    hasAnyTags?: string[];\n    createdAfter?: Date;\n    createdBefore?: Date;\n    modifiedAfter?: Date;\n    modifiedBefore?: Date;\n    minLength?: number;\n    maxLength?: number;\n    isPinned?: boolean;\n    isArchived?: boolean;\n    isTrashed?: boolean;\n    isEncrypted?: boolean;\n  }): Promise<NoteWithTags[]> {\n    await this.database.connect(true);\n\n    try {\n      let sql = `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               LENGTH(n.ZTEXT) as content_length\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE 1=1\n      `;\n\n      const params: any[] = [];\n\n      // Title search (OR logic for multiple terms)\n      if (criteria.titleContains && criteria.titleContains.length > 0) {\n        const titleConditions = criteria.titleContains.map(() => 'n.ZTITLE LIKE ?').join(' OR ');\n        sql += ` AND (${titleConditions})`;\n        criteria.titleContains.forEach(term => params.push(`%${term}%`));\n      }\n\n      // Content search (OR logic for multiple terms)\n      if (criteria.contentContains && criteria.contentContains.length > 0) {\n        const contentConditions = criteria.contentContains.map(() => 'n.ZTEXT LIKE ?').join(' OR ');\n        sql += ` AND (${contentConditions})`;\n        criteria.contentContains.forEach(term => params.push(`%${term}%`));\n      }\n\n      // Date filters\n      if (criteria.createdAfter) {\n        sql += ' AND n.ZCREATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(criteria.createdAfter));\n      }\n\n      if (criteria.createdBefore) {\n        sql += ' AND n.ZCREATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(criteria.createdBefore));\n      }\n\n      if (criteria.modifiedAfter) {\n        sql += ' AND n.ZMODIFICATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(criteria.modifiedAfter));\n      }\n\n      if (criteria.modifiedBefore) {\n        sql += ' AND n.ZMODIFICATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(criteria.modifiedBefore));\n      }\n\n      // Content length filters\n      if (criteria.minLength) {\n        sql += ' AND LENGTH(n.ZTEXT) >= ?';\n        params.push(criteria.minLength);\n      }\n\n      if (criteria.maxLength) {\n        sql += ' AND LENGTH(n.ZTEXT) <= ?';\n        params.push(criteria.maxLength);\n      }\n\n      // Boolean filters\n      if (criteria.isPinned !== undefined) {\n        sql += ' AND n.ZPINNED = ?';\n        params.push(criteria.isPinned ? 1 : 0);\n      }\n\n      if (criteria.isArchived !== undefined) {\n        sql += ' AND n.ZARCHIVED = ?';\n        params.push(criteria.isArchived ? 1 : 0);\n      }\n\n      if (criteria.isTrashed !== undefined) {\n        sql += ' AND n.ZTRASHED = ?';\n        params.push(criteria.isTrashed ? 1 : 0);\n      }\n\n      if (criteria.isEncrypted !== undefined) {\n        sql += ' AND n.ZENCRYPTED = ?';\n        params.push(criteria.isEncrypted ? 1 : 0);\n      }\n\n      sql += ' GROUP BY n.Z_PK';\n\n      // Tag filters (applied after grouping)\n      if (criteria.hasAllTags && criteria.hasAllTags.length > 0) {\n        const allTagConditions = criteria.hasAllTags.map(() => 'tag_names LIKE ?').join(' AND ');\n        sql += ` HAVING ${allTagConditions}`;\n        criteria.hasAllTags.forEach(tag => params.push(`%${tag}%`));\n      }\n\n      if (criteria.hasAnyTags && criteria.hasAnyTags.length > 0) {\n        const anyTagConditions = criteria.hasAnyTags.map(() => 'tag_names LIKE ?').join(' OR ');\n        const havingClause = criteria.hasAllTags\n          ? ` AND (${anyTagConditions})`\n          : ` HAVING (${anyTagConditions})`;\n        sql += havingClause;\n        criteria.hasAnyTags.forEach(tag => params.push(`%${tag}%`));\n      }\n\n      sql += ' ORDER BY n.ZMODIFICATIONDATE DESC';\n\n      const rows = await this.database.query<\n        BearNote & {\n          tag_names: string;\n          content_length: number;\n        }\n      >(sql, params);\n\n      return rows.map(row => ({\n        ...row,\n        tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n        contentLength: row.content_length,\n      }));\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get note statistics and analytics\n   */\n  async getNoteAnalytics(): Promise<{\n    totalNotes: number;\n    averageLength: number;\n    longestNote: { title: string; length: number };\n    shortestNote: { title: string; length: number };\n    mostRecentNote: { title: string; date: Date };\n    oldestNote: { title: string; date: Date };\n    notesPerMonth: { month: string; count: number }[];\n    topTags: { tag: string; count: number }[];\n    contentStats: {\n      hasImages: number;\n      hasFiles: number;\n      hasSourceCode: number;\n      hasTodos: number;\n    };\n  }> {\n    await this.database.connect(true);\n\n    try {\n      const [totalStats, longestNote, shortestNote, mostRecentNote, oldestNote, contentStats] =\n        await Promise.all([\n          this.database.queryOne<{ count: number; avgLength: number }>(`\n          SELECT COUNT(*) as count, AVG(LENGTH(ZTEXT)) as avgLength\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0\n        `),\n          this.database.queryOne<{ ZTITLE: string; length: number }>(`\n          SELECT ZTITLE, LENGTH(ZTEXT) as length\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n          ORDER BY LENGTH(ZTEXT) DESC \n          LIMIT 1\n        `),\n          this.database.queryOne<{ ZTITLE: string; length: number }>(`\n          SELECT ZTITLE, LENGTH(ZTEXT) as length\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n          ORDER BY LENGTH(ZTEXT) ASC \n          LIMIT 1\n        `),\n          this.database.queryOne<{ ZTITLE: string; ZMODIFICATIONDATE: number }>(`\n          SELECT ZTITLE, ZMODIFICATIONDATE\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0\n          ORDER BY ZMODIFICATIONDATE DESC \n          LIMIT 1\n        `),\n          this.database.queryOne<{ ZTITLE: string; ZCREATIONDATE: number }>(`\n          SELECT ZTITLE, ZCREATIONDATE\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0\n          ORDER BY ZCREATIONDATE ASC \n          LIMIT 1\n        `),\n          this.database.queryOne<{\n            hasImages: number;\n            hasFiles: number;\n            hasSourceCode: number;\n            todos: number;\n          }>(`\n          SELECT \n            SUM(ZHASIMAGES) as hasImages,\n            SUM(ZHASFILES) as hasFiles,\n            SUM(ZHASSOURCECODE) as hasSourceCode,\n            SUM(ZTODOCOMPLETED + ZTODOINCOMPLETED) as todos\n          FROM ZSFNOTE \n          WHERE ZTRASHED = 0\n        `),\n        ]);\n\n      // Get monthly note creation stats\n      const monthlyStats = await this.database.query<{ month: string; count: number }>(`\n        SELECT \n          strftime('%Y-%m', datetime(ZCREATIONDATE + 978307200, 'unixepoch')) as month,\n          COUNT(*) as count\n        FROM ZSFNOTE \n        WHERE ZTRASHED = 0\n        GROUP BY month\n        ORDER BY month DESC\n        LIMIT 12\n      `);\n\n      // Get top tags\n      const topTags = await this.database.query<{ ZTITLE: string; count: number }>(`\n        SELECT t.ZTITLE, COUNT(nt.Z_5NOTES) as count\n        FROM ZSFNOTETAG t\n        JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS\n        JOIN ZSFNOTE n ON nt.Z_5NOTES = n.Z_PK AND n.ZTRASHED = 0\n        GROUP BY t.Z_PK, t.ZTITLE\n        ORDER BY count DESC\n        LIMIT 10\n      `);\n\n      return {\n        totalNotes: totalStats?.count || 0,\n        averageLength: Math.round(totalStats?.avgLength || 0),\n        longestNote: {\n          title: longestNote?.ZTITLE || '',\n          length: longestNote?.length || 0,\n        },\n        shortestNote: {\n          title: shortestNote?.ZTITLE || '',\n          length: shortestNote?.length || 0,\n        },\n        mostRecentNote: {\n          title: mostRecentNote?.ZTITLE || '',\n          date: mostRecentNote\n            ? CoreDataUtils.toDate(mostRecentNote.ZMODIFICATIONDATE)\n            : new Date(),\n        },\n        oldestNote: {\n          title: oldestNote?.ZTITLE || '',\n          date: oldestNote ? CoreDataUtils.toDate(oldestNote.ZCREATIONDATE) : new Date(),\n        },\n        notesPerMonth: monthlyStats.map(stat => ({\n          month: stat.month,\n          count: stat.count,\n        })),\n        topTags: topTags.map(tag => ({\n          tag: tag.ZTITLE,\n          count: tag.count,\n        })),\n        contentStats: {\n          hasImages: contentStats?.hasImages || 0,\n          hasFiles: contentStats?.hasFiles || 0,\n          hasSourceCode: contentStats?.hasSourceCode || 0,\n          hasTodos: contentStats?.todos || 0,\n        },\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Find related notes based on content similarity and shared tags\n   */\n  async getRelatedNotes(\n    noteId: number,\n    limit: number = 5\n  ): Promise<{\n    byTags: NoteWithTags[];\n    byContent: NoteWithTags[];\n  }> {\n    await this.database.connect(true);\n\n    try {\n      // Get the source note's tags and content keywords\n      const sourceNote = await this.getNoteById(noteId);\n      if (!sourceNote) {\n        return { byTags: [], byContent: [] };\n      }\n\n      // Find notes with shared tags\n      const relatedByTags =\n        sourceNote.tags.length > 0\n          ? await this.database.query<BearNote & { tag_names: string; shared_tags: number }>(\n              `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               COUNT(DISTINCT CASE WHEN t.ZTITLE IN (${sourceNote.tags.map(() => '?').join(',')}) THEN t.ZTITLE END) as shared_tags\n        FROM ZSFNOTE n\n        JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE n.Z_PK != ? AND n.ZTRASHED = 0\n        GROUP BY n.Z_PK\n        HAVING shared_tags > 0\n        ORDER BY shared_tags DESC, n.ZMODIFICATIONDATE DESC\n        LIMIT ?\n      `,\n              [...sourceNote.tags, noteId, limit]\n            )\n          : [];\n\n      // Find notes with similar content (basic keyword matching)\n      const contentKeywords = this.extractKeywords(sourceNote.ZTEXT || '');\n      const relatedByContent =\n        contentKeywords.length > 0\n          ? await this.database.query<BearNote & { tag_names: string }>(\n              `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE n.Z_PK != ? AND n.ZTRASHED = 0\n          AND (${contentKeywords.map(() => 'n.ZTEXT LIKE ?').join(' OR ')})\n        GROUP BY n.Z_PK\n        ORDER BY n.ZMODIFICATIONDATE DESC\n        LIMIT ?\n      `,\n              [noteId, ...contentKeywords.map(kw => `%${kw}%`), limit]\n            )\n          : [];\n\n      return {\n        byTags: relatedByTags.map(row => ({\n          ...row,\n          tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n        })),\n        byContent: relatedByContent.map(row => ({\n          ...row,\n          tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n        })),\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Extract keywords from text for content similarity matching\n   */\n  private extractKeywords(text: string): string[] {\n    if (!text) {\n      return [];\n    }\n\n    // Simple keyword extraction - remove common words and get significant terms\n    const commonWords = new Set([\n      'the',\n      'a',\n      'an',\n      'and',\n      'or',\n      'but',\n      'in',\n      'on',\n      'at',\n      'to',\n      'for',\n      'of',\n      'with',\n      'by',\n      'is',\n      'are',\n      'was',\n      'were',\n      'be',\n      'been',\n      'have',\n      'has',\n      'had',\n      'do',\n      'does',\n      'did',\n      'will',\n      'would',\n      'could',\n      'should',\n      'this',\n      'that',\n      'these',\n      'those',\n    ]);\n\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(word => word.length > 3 && !commonWords.has(word))\n      .slice(0, 10); // Top 10 keywords\n  }\n\n  /**\n   * Advanced full-text search with ranking and relevance scoring\n   */\n  async searchNotesFullText(\n    query: string,\n    options: {\n      limit?: number;\n      includeSnippets?: boolean;\n      searchFields?: ('title' | 'content' | 'both')[];\n      fuzzyMatch?: boolean;\n      caseSensitive?: boolean;\n      wholeWords?: boolean;\n      includeArchived?: boolean;\n      includeTrashed?: boolean;\n      tags?: string[];\n      dateFrom?: Date;\n      dateTo?: Date;\n    } = {}\n  ): Promise<\n    Array<\n      NoteWithTags & {\n        relevanceScore: number;\n        matchedTerms: string[];\n        snippets: string[];\n        titleMatches: number;\n        contentMatches: number;\n      }\n    >\n  > {\n    await this.database.connect(true);\n\n    try {\n      const searchTerms = this.extractSearchTerms(query, options.fuzzyMatch);\n      const searchFields = options.searchFields || ['both'];\n\n      let sql = `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               LENGTH(n.ZTEXT) as content_length\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE 1=1\n      `;\n\n      const params: any[] = [];\n\n      // Basic filters\n      if (!options.includeTrashed) {\n        sql += ' AND n.ZTRASHED = 0';\n      }\n\n      if (!options.includeArchived) {\n        sql += ' AND n.ZARCHIVED = 0';\n      }\n\n      // Build search conditions\n      const searchConditions: string[] = [];\n\n      if (searchFields.includes('title') || searchFields.includes('both')) {\n        const titleConditions = searchTerms.map(() =>\n          options.caseSensitive ? 'n.ZTITLE LIKE ?' : 'LOWER(n.ZTITLE) LIKE LOWER(?)'\n        );\n        if (titleConditions.length > 0) {\n          searchConditions.push(`(${titleConditions.join(' OR ')})`);\n          searchTerms.forEach(term => params.push(`%${term}%`));\n        }\n      }\n\n      if (searchFields.includes('content') || searchFields.includes('both')) {\n        const contentConditions = searchTerms.map(() =>\n          options.caseSensitive ? 'n.ZTEXT LIKE ?' : 'LOWER(n.ZTEXT) LIKE LOWER(?)'\n        );\n        if (contentConditions.length > 0) {\n          searchConditions.push(`(${contentConditions.join(' OR ')})`);\n          searchTerms.forEach(term => params.push(`%${term}%`));\n        }\n      }\n\n      if (searchConditions.length > 0) {\n        sql += ` AND (${searchConditions.join(' OR ')})`;\n      }\n\n      // Tag filters\n      if (options.tags && options.tags.length > 0) {\n        sql += ' GROUP BY n.Z_PK HAVING ';\n        const tagConditions = options.tags.map(() => 'tag_names LIKE ?').join(' AND ');\n        sql += tagConditions;\n        options.tags.forEach(tag => params.push(`%${tag}%`));\n      } else {\n        sql += ' GROUP BY n.Z_PK';\n      }\n\n      // Date filters\n      if (options.dateFrom) {\n        sql += ' AND n.ZCREATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(options.dateFrom));\n      }\n\n      if (options.dateTo) {\n        sql += ' AND n.ZCREATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(options.dateTo));\n      }\n\n      sql += ' ORDER BY n.ZMODIFICATIONDATE DESC';\n\n      if (options.limit) {\n        sql += ' LIMIT ?';\n        params.push(options.limit);\n      }\n\n      const rows = await this.database.query<\n        BearNote & {\n          tag_names: string;\n          content_length: number;\n        }\n      >(sql, params);\n\n      // Calculate relevance scores and extract snippets\n      return rows\n        .map(row => {\n          const note = {\n            ...row,\n            tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n            contentLength: row.content_length,\n          };\n\n          const analysis = this.analyzeSearchMatches(note, searchTerms, options);\n\n          return {\n            ...note,\n            relevanceScore: analysis.relevanceScore,\n            matchedTerms: analysis.matchedTerms,\n            snippets: options.includeSnippets ? analysis.snippets : [],\n            titleMatches: analysis.titleMatches,\n            contentMatches: analysis.contentMatches,\n          };\n        })\n        .sort((a, b) => b.relevanceScore - a.relevanceScore);\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Search with auto-complete suggestions\n   */\n  async getSearchSuggestions(\n    partialQuery: string,\n    limit: number = 10\n  ): Promise<{\n    terms: string[];\n    titles: string[];\n    tags: string[];\n  }> {\n    await this.database.connect(true);\n\n    try {\n      const [termSuggestions, titleSuggestions, tagSuggestions] = await Promise.all([\n        // Extract common words from content that start with the partial query\n        this.database.query<{ term: string; frequency: number }>(\n          `\n          WITH RECURSIVE split(word, str) AS (\n            SELECT '', LOWER(ZTEXT) || ' ' FROM ZSFNOTE WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n            UNION ALL\n            SELECT substr(str, 0, instr(str, ' ')), \n                   substr(str, instr(str, ' ') + 1)\n            FROM split WHERE str != ''\n          )\n          SELECT word as term, COUNT(*) as frequency\n          FROM split \n          WHERE word LIKE ? AND LENGTH(word) > 2\n          GROUP BY word\n          ORDER BY frequency DESC\n          LIMIT ?\n        `,\n          [`${partialQuery.toLowerCase()}%`, limit]\n        ),\n\n        // Find note titles that contain the partial query\n        this.database.query<{ title: string }>(\n          `\n          SELECT DISTINCT ZTITLE as title\n          FROM ZSFNOTE \n          WHERE ZTITLE LIKE ? AND ZTRASHED = 0 AND ZTITLE IS NOT NULL\n          ORDER BY ZMODIFICATIONDATE DESC\n          LIMIT ?\n        `,\n          [`%${partialQuery}%`, limit]\n        ),\n\n        // Find tags that start with the partial query\n        this.database.query<{ tag: string }>(\n          `\n          SELECT DISTINCT ZTITLE as tag\n          FROM ZSFNOTETAG \n          WHERE ZTITLE LIKE ?\n          ORDER BY ZTITLE\n          LIMIT ?\n        `,\n          [`${partialQuery}%`, limit]\n        ),\n      ]);\n\n      return {\n        terms: termSuggestions.map(s => s.term),\n        titles: titleSuggestions.map(s => s.title),\n        tags: tagSuggestions.map(s => s.tag),\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Search for similar notes using content analysis\n   */\n  async findSimilarNotes(\n    referenceText: string,\n    options: {\n      limit?: number;\n      minSimilarity?: number;\n      excludeNoteId?: number;\n    } = {}\n  ): Promise<Array<NoteWithTags & { similarityScore: number; commonKeywords: string[] }>> {\n    await this.database.connect(true);\n\n    try {\n      const referenceKeywords = this.extractKeywords(referenceText);\n      if (referenceKeywords.length === 0) {\n        return [];\n      }\n\n      let sql = `\n        SELECT n.*, GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               LENGTH(n.ZTEXT) as content_length\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        WHERE n.ZTRASHED = 0 AND n.ZTEXT IS NOT NULL\n      `;\n\n      const params: any[] = [];\n\n      if (options.excludeNoteId) {\n        sql += ' AND n.Z_PK != ?';\n        params.push(options.excludeNoteId);\n      }\n\n      // Add keyword matching conditions\n      const keywordConditions = referenceKeywords\n        .map(() => 'LOWER(n.ZTEXT) LIKE LOWER(?)')\n        .join(' OR ');\n      sql += ` AND (${keywordConditions})`;\n      referenceKeywords.forEach(keyword => params.push(`%${keyword}%`));\n\n      sql += ' GROUP BY n.Z_PK ORDER BY n.ZMODIFICATIONDATE DESC';\n\n      if (options.limit) {\n        sql += ' LIMIT ?';\n        params.push(options.limit * 3); // Get more results for similarity filtering\n      }\n\n      const rows = await this.database.query<\n        BearNote & {\n          tag_names: string;\n          content_length: number;\n        }\n      >(sql, params);\n\n      // Calculate similarity scores\n      const results = rows\n        .map(row => {\n          const note = {\n            ...row,\n            tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n            contentLength: row.content_length,\n          };\n\n          const noteKeywords = this.extractKeywords(note.ZTEXT || '');\n          const commonKeywords = referenceKeywords.filter(kw =>\n            noteKeywords.some(nkw => nkw.includes(kw) || kw.includes(nkw))\n          );\n\n          const similarityScore =\n            commonKeywords.length / Math.max(referenceKeywords.length, noteKeywords.length);\n\n          return {\n            ...note,\n            similarityScore,\n            commonKeywords,\n          };\n        })\n        .filter(result => result.similarityScore >= (options.minSimilarity || 0.1))\n        .sort((a, b) => b.similarityScore - a.similarityScore)\n        .slice(0, options.limit || 10);\n\n      return results;\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Extract search terms with optional fuzzy matching\n   */\n  private extractSearchTerms(query: string, fuzzyMatch: boolean = false): string[] {\n    const terms = query\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(term => term.length > 1);\n\n    if (fuzzyMatch) {\n      // Add fuzzy variations (simple approach - could be enhanced with Levenshtein distance)\n      const fuzzyTerms: string[] = [];\n      terms.forEach(term => {\n        fuzzyTerms.push(term);\n        if (term.length > 3) {\n          // Add terms with one character missing\n          for (let i = 0; i < term.length; i++) {\n            fuzzyTerms.push(term.substring(0, i) + term.substring(i + 1));\n          }\n        }\n      });\n      return [...new Set(fuzzyTerms)]; // Remove duplicates\n    }\n\n    return terms;\n  }\n\n  /**\n   * Analyze search matches and calculate relevance\n   */\n  private analyzeSearchMatches(\n    note: NoteWithTags,\n    searchTerms: string[],\n    options: any\n  ): {\n    relevanceScore: number;\n    matchedTerms: string[];\n    snippets: string[];\n    titleMatches: number;\n    contentMatches: number;\n  } {\n    const title = note.ZTITLE?.toLowerCase() || '';\n    const content = note.ZTEXT?.toLowerCase() || '';\n\n    let titleMatches = 0;\n    let contentMatches = 0;\n    const matchedTerms: string[] = [];\n    const snippets: string[] = [];\n\n    searchTerms.forEach(term => {\n      const termLower = term.toLowerCase();\n\n      // Count title matches\n      const titleMatchCount = (title.match(new RegExp(termLower, 'g')) || []).length;\n      if (titleMatchCount > 0) {\n        titleMatches += titleMatchCount;\n        matchedTerms.push(term);\n      }\n\n      // Count content matches and extract snippets\n      const contentMatchCount = (content.match(new RegExp(termLower, 'g')) || []).length;\n      if (contentMatchCount > 0) {\n        contentMatches += contentMatchCount;\n        if (!matchedTerms.includes(term)) {\n          matchedTerms.push(term);\n        }\n\n        // Extract snippet around the match\n        const matchIndex = content.indexOf(termLower);\n        if (matchIndex !== -1 && snippets.length < 3) {\n          const start = Math.max(0, matchIndex - 50);\n          const end = Math.min(content.length, matchIndex + 100);\n          const snippet = content.substring(start, end);\n          snippets.push(`...${snippet}...`);\n        }\n      }\n    });\n\n    // Calculate relevance score\n    let relevanceScore = 0;\n\n    // Title matches are weighted more heavily\n    relevanceScore += titleMatches * 10;\n\n    // Content matches\n    relevanceScore += contentMatches * 2;\n\n    // Boost for exact phrase matches\n    const queryLower = searchTerms.join(' ').toLowerCase();\n    if (title.includes(queryLower)) {\n      relevanceScore += 20;\n    }\n    if (content.includes(queryLower)) {\n      relevanceScore += 5;\n    }\n\n    // Boost for tag matches\n    const tagMatches = note.tags.filter(tag =>\n      searchTerms.some(term => tag.toLowerCase().includes(term.toLowerCase()))\n    ).length;\n    relevanceScore += tagMatches * 15;\n\n    // Normalize by content length (favor shorter, more focused content)\n    if (note.contentLength && note.contentLength > 0) {\n      relevanceScore = relevanceScore / Math.log(note.contentLength + 1);\n    }\n\n    return {\n      relevanceScore,\n      matchedTerms,\n      snippets,\n      titleMatches,\n      contentMatches,\n    };\n  }\n\n  /**\n   * Get comprehensive file attachment information\n   */\n  async getFileAttachments(\n    options: {\n      noteId?: number;\n      fileType?: string;\n      includeMetadata?: boolean;\n      limit?: number;\n    } = {}\n  ): Promise<{\n    totalAttachments: number;\n    attachments: Array<{\n      id: number;\n      filename: string;\n      fileType: string;\n      fileSize: number;\n      createdAt: Date;\n      modifiedAt: Date;\n      noteId: number;\n      noteTitle: string;\n      filePath: string;\n      contentType: string;\n      metadata?: any;\n    }>;\n    attachmentsByType: Array<{ type: string; count: number; totalSize: number }>;\n  }> {\n    await this.database.connect(true);\n\n    try {\n      let sql = `\n        SELECT f.*, n.ZTITLE as note_title, n.Z_PK as note_id\n        FROM ZSFNOTEFILE f\n        INNER JOIN ZSFNOTE n ON f.ZNOTE = n.Z_PK\n        WHERE n.ZTRASHED = 0\n      `;\n\n      const params: any[] = [];\n\n      if (options.noteId) {\n        sql += ' AND f.ZNOTE = ?';\n        params.push(options.noteId);\n      }\n\n      if (options.fileType) {\n        sql += ' AND LOWER(f.ZFILENAME) LIKE LOWER(?)';\n        params.push(`%.${options.fileType}`);\n      }\n\n      sql += ' ORDER BY f.ZCREATIONDATE DESC';\n\n      if (options.limit) {\n        sql += ' LIMIT ?';\n        params.push(options.limit);\n      }\n\n      const files = await this.database.query<any>(sql, params);\n\n      // Get attachment statistics by type\n      const typeStats = await this.database.query<{\n        type: string;\n        count: number;\n        total_size: number;\n      }>(`\n        SELECT \n          CASE \n            WHEN LOWER(f.ZFILENAME) LIKE '%.jpg' OR LOWER(f.ZFILENAME) LIKE '%.jpeg' OR \n                 LOWER(f.ZFILENAME) LIKE '%.png' OR LOWER(f.ZFILENAME) LIKE '%.gif' OR\n                 LOWER(f.ZFILENAME) LIKE '%.webp' THEN 'image'\n            WHEN LOWER(f.ZFILENAME) LIKE '%.pdf' THEN 'pdf'\n            WHEN LOWER(f.ZFILENAME) LIKE '%.doc' OR LOWER(f.ZFILENAME) LIKE '%.docx' OR\n                 LOWER(f.ZFILENAME) LIKE '%.txt' OR LOWER(f.ZFILENAME) LIKE '%.md' THEN 'document'\n            WHEN LOWER(f.ZFILENAME) LIKE '%.mp4' OR LOWER(f.ZFILENAME) LIKE '%.mov' OR\n                 LOWER(f.ZFILENAME) LIKE '%.avi' THEN 'video'\n            WHEN LOWER(f.ZFILENAME) LIKE '%.mp3' OR LOWER(f.ZFILENAME) LIKE '%.wav' OR\n                 LOWER(f.ZFILENAME) LIKE '%.m4a' THEN 'audio'\n            ELSE 'other'\n          END as type,\n          COUNT(*) as count,\n          COALESCE(SUM(f.ZFILESIZE), 0) as total_size\n        FROM ZSFNOTEFILE f\n        INNER JOIN ZSFNOTE n ON f.ZNOTE = n.Z_PK\n        WHERE n.ZTRASHED = 0\n        GROUP BY type\n        ORDER BY count DESC\n      `);\n\n      const attachments = files.map((file: any) => {\n        const filename = file.ZFILENAME || 'unknown';\n        const extension = filename.split('.').pop()?.toLowerCase() || '';\n\n        let contentType = 'application/octet-stream';\n        let fileType = 'other';\n\n        // Determine content type and file type\n        if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(extension)) {\n          contentType = `image/${extension === 'jpg' ? 'jpeg' : extension}`;\n          fileType = 'image';\n        } else if (extension === 'pdf') {\n          contentType = 'application/pdf';\n          fileType = 'pdf';\n        } else if (['doc', 'docx'].includes(extension)) {\n          contentType = 'application/msword';\n          fileType = 'document';\n        } else if (['txt', 'md'].includes(extension)) {\n          contentType = 'text/plain';\n          fileType = 'document';\n        } else if (['mp4', 'mov', 'avi'].includes(extension)) {\n          contentType = `video/${extension}`;\n          fileType = 'video';\n        } else if (['mp3', 'wav', 'm4a'].includes(extension)) {\n          contentType = `audio/${extension}`;\n          fileType = 'audio';\n        }\n\n        return {\n          id: file.Z_PK,\n          filename,\n          fileType,\n          fileSize: file.ZFILESIZE || 0,\n          createdAt: CoreDataUtils.toDate(file.ZCREATIONDATE),\n          modifiedAt: CoreDataUtils.toDate(file.ZMODIFICATIONDATE),\n          noteId: file.note_id,\n          noteTitle: file.note_title || 'Untitled',\n          filePath: file.ZFILEPATH || '',\n          contentType,\n          metadata: options.includeMetadata ? this.extractFileMetadata(file) : undefined,\n        };\n      });\n\n      return {\n        totalAttachments: files.length,\n        attachments,\n        attachmentsByType: typeStats.map(stat => ({\n          type: stat.type,\n          count: stat.count,\n          totalSize: stat.total_size,\n        })),\n      };\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Analyze note metadata and content patterns\n   */\n  async analyzeNoteMetadata(\n    options: {\n      includeContentAnalysis?: boolean;\n      includeLinkAnalysis?: boolean;\n      includeStructureAnalysis?: boolean;\n    } = {}\n  ): Promise<{\n    overview: {\n      totalNotes: number;\n      averageLength: number;\n      lengthDistribution: Array<{ range: string; count: number }>;\n      creationPatterns: Array<{ hour: number; count: number }>;\n      modificationPatterns: Array<{ hour: number; count: number }>;\n    };\n    contentAnalysis?: {\n      markdownUsage: {\n        headings: number;\n        lists: number;\n        codeBlocks: number;\n        links: number;\n        images: number;\n        tables: number;\n      };\n      languagePatterns: Array<{ language: string; count: number }>;\n      commonPatterns: Array<{ pattern: string; description: string; count: number }>;\n    };\n    linkAnalysis?: {\n      internalLinks: number;\n      externalLinks: number;\n      brokenLinks: number;\n      topDomains: Array<{ domain: string; count: number }>;\n      linkTypes: Array<{ type: string; count: number }>;\n    };\n    structureAnalysis?: {\n      titlePatterns: Array<{ pattern: string; count: number; examples: string[] }>;\n      averageWordsPerNote: number;\n      averageParagraphsPerNote: number;\n      notesWithTodos: number;\n      notesWithDates: number;\n      notesWithNumbers: number;\n    };\n  }> {\n    await this.database.connect(true);\n\n    try {\n      // Basic overview\n      const [overview] = await this.database.query<{\n        total_notes: number;\n        avg_length: number;\n      }>(`\n        SELECT \n          COUNT(*) as total_notes,\n          AVG(LENGTH(ZTEXT)) as avg_length\n        FROM ZSFNOTE \n        WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n      `);\n\n      // Length distribution\n      const lengthDistribution = await this.database.query<{\n        range: string;\n        count: number;\n      }>(`\n        SELECT \n          CASE \n            WHEN LENGTH(ZTEXT) < 100 THEN '0-100'\n            WHEN LENGTH(ZTEXT) < 500 THEN '100-500'\n            WHEN LENGTH(ZTEXT) < 1000 THEN '500-1K'\n            WHEN LENGTH(ZTEXT) < 5000 THEN '1K-5K'\n            WHEN LENGTH(ZTEXT) < 10000 THEN '5K-10K'\n            ELSE '10K+'\n          END as range,\n          COUNT(*) as count\n        FROM ZSFNOTE \n        WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n        GROUP BY range\n        ORDER BY \n          CASE range\n            WHEN '0-100' THEN 1\n            WHEN '100-500' THEN 2\n            WHEN '500-1K' THEN 3\n            WHEN '1K-5K' THEN 4\n            WHEN '5K-10K' THEN 5\n            ELSE 6\n          END\n      `);\n\n      // Creation and modification patterns by hour\n      const creationPatterns = await this.database.query<{\n        hour: number;\n        count: number;\n      }>(`\n        SELECT \n          CAST(strftime('%H', datetime(ZCREATIONDATE + 978307200, 'unixepoch', 'localtime')) AS INTEGER) as hour,\n          COUNT(*) as count\n        FROM ZSFNOTE \n        WHERE ZTRASHED = 0\n        GROUP BY hour\n        ORDER BY hour\n      `);\n\n      const modificationPatterns = await this.database.query<{\n        hour: number;\n        count: number;\n      }>(`\n        SELECT \n          CAST(strftime('%H', datetime(ZMODIFICATIONDATE + 978307200, 'unixepoch', 'localtime')) AS INTEGER) as hour,\n          COUNT(*) as count\n        FROM ZSFNOTE \n        WHERE ZTRASHED = 0\n        GROUP BY hour\n        ORDER BY hour\n      `);\n\n      const result: any = {\n        overview: {\n          totalNotes: overview.total_notes,\n          averageLength: Math.round(overview.avg_length || 0),\n          lengthDistribution,\n          creationPatterns,\n          modificationPatterns,\n        },\n      };\n\n      // Content analysis\n      if (options.includeContentAnalysis) {\n        const notes = await this.database.query<{ text: string }>(`\n          SELECT ZTEXT as text FROM ZSFNOTE \n          WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n          LIMIT 1000\n        `);\n\n        const contentAnalysis = this.analyzeContent(notes.map(n => n.text));\n        result.contentAnalysis = contentAnalysis;\n      }\n\n      // Link analysis\n      if (options.includeLinkAnalysis) {\n        const notes = await this.database.query<{ text: string }>(`\n          SELECT ZTEXT as text FROM ZSFNOTE \n          WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n          AND (ZTEXT LIKE '%http%' OR ZTEXT LIKE '%www.%' OR ZTEXT LIKE '%[%](%')\n          LIMIT 1000\n        `);\n\n        const linkAnalysis = this.analyzeLinks(notes.map(n => n.text));\n        result.linkAnalysis = linkAnalysis;\n      }\n\n      // Structure analysis\n      if (options.includeStructureAnalysis) {\n        const notes = await this.database.query<{ title: string; text: string }>(`\n          SELECT ZTITLE as title, ZTEXT as text FROM ZSFNOTE \n          WHERE ZTRASHED = 0 AND ZTEXT IS NOT NULL\n          LIMIT 1000\n        `);\n\n        const structureAnalysis = this.analyzeStructure(notes);\n        result.structureAnalysis = structureAnalysis;\n      }\n\n      return result;\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Get notes with specific metadata characteristics\n   */\n  async getNotesWithMetadata(criteria: {\n    hasAttachments?: boolean;\n    hasLinks?: boolean;\n    hasImages?: boolean;\n    hasTodos?: boolean;\n    hasCodeBlocks?: boolean;\n    hasTables?: boolean;\n    minWordCount?: number;\n    maxWordCount?: number;\n    createdAfter?: Date;\n    createdBefore?: Date;\n    modifiedAfter?: Date;\n    modifiedBefore?: Date;\n    limit?: number;\n  }): Promise<\n    Array<\n      NoteWithTags & {\n        wordCount: number;\n        attachmentCount: number;\n        linkCount: number;\n        imageCount: number;\n        todoCount: number;\n        codeBlockCount: number;\n        tableCount: number;\n        metadata: {\n          hasAttachments: boolean;\n          hasLinks: boolean;\n          hasImages: boolean;\n          hasTodos: boolean;\n          hasCodeBlocks: boolean;\n          hasTables: boolean;\n        };\n      }\n    >\n  > {\n    await this.database.connect(true);\n\n    try {\n      let sql = `\n        SELECT n.*, \n               GROUP_CONCAT(DISTINCT t.ZTITLE) as tag_names,\n               COUNT(DISTINCT f.Z_PK) as attachment_count\n        FROM ZSFNOTE n\n        LEFT JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES\n        LEFT JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK\n        LEFT JOIN ZSFNOTEFILE f ON n.Z_PK = f.ZNOTE\n        WHERE n.ZTRASHED = 0\n      `;\n\n      const params: any[] = [];\n\n      // Date filters\n      if (criteria.createdAfter) {\n        sql += ' AND n.ZCREATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(criteria.createdAfter));\n      }\n\n      if (criteria.createdBefore) {\n        sql += ' AND n.ZCREATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(criteria.createdBefore));\n      }\n\n      if (criteria.modifiedAfter) {\n        sql += ' AND n.ZMODIFICATIONDATE >= ?';\n        params.push(CoreDataUtils.fromDate(criteria.modifiedAfter));\n      }\n\n      if (criteria.modifiedBefore) {\n        sql += ' AND n.ZMODIFICATIONDATE <= ?';\n        params.push(CoreDataUtils.fromDate(criteria.modifiedBefore));\n      }\n\n      // Attachment filter\n      if (criteria.hasAttachments === true) {\n        sql += ' AND f.Z_PK IS NOT NULL';\n      } else if (criteria.hasAttachments === false) {\n        sql += ' AND f.Z_PK IS NULL';\n      }\n\n      sql += ' GROUP BY n.Z_PK ORDER BY n.ZMODIFICATIONDATE DESC';\n\n      if (criteria.limit) {\n        sql += ' LIMIT ?';\n        params.push(criteria.limit);\n      }\n\n      const rows = await this.database.query<\n        BearNote & {\n          tag_names: string;\n          attachment_count: number;\n        }\n      >(sql, params);\n\n      // Analyze content for each note\n      const results = rows\n        .map(row => {\n          const note = {\n            ...row,\n            tags: row.tag_names ? row.tag_names.split(',').filter(Boolean) : [],\n          };\n\n          const content = note.ZTEXT || '';\n\n          // Count various content elements\n          const wordCount = content.split(/\\s+/).filter(word => word.length > 0).length;\n          const linkCount = (content.match(/https?:\\/\\/[^\\s\\)]+/g) || []).length;\n          const imageCount = (content.match(/!\\[.*?\\]\\(.*?\\)/g) || []).length;\n          const todoCount = (content.match(/- \\[[ x]\\]/g) || []).length;\n          const codeBlockCount = (content.match(/```/g) || []).length / 2;\n          const tableCount = (content.match(/\\|.*\\|/g) || []).length;\n\n          // Apply content-based filters\n          if (criteria.minWordCount && wordCount < criteria.minWordCount) {\n            return null;\n          }\n          if (criteria.maxWordCount && wordCount > criteria.maxWordCount) {\n            return null;\n          }\n          if (criteria.hasLinks === true && linkCount === 0) {\n            return null;\n          }\n          if (criteria.hasLinks === false && linkCount > 0) {\n            return null;\n          }\n          if (criteria.hasImages === true && imageCount === 0) {\n            return null;\n          }\n          if (criteria.hasImages === false && imageCount > 0) {\n            return null;\n          }\n          if (criteria.hasTodos === true && todoCount === 0) {\n            return null;\n          }\n          if (criteria.hasTodos === false && todoCount > 0) {\n            return null;\n          }\n          if (criteria.hasCodeBlocks === true && codeBlockCount === 0) {\n            return null;\n          }\n          if (criteria.hasCodeBlocks === false && codeBlockCount > 0) {\n            return null;\n          }\n          if (criteria.hasTables === true && tableCount === 0) {\n            return null;\n          }\n          if (criteria.hasTables === false && tableCount > 0) {\n            return null;\n          }\n\n          return {\n            ...note,\n            wordCount,\n            attachmentCount: row.attachment_count,\n            linkCount,\n            imageCount,\n            todoCount,\n            codeBlockCount,\n            tableCount,\n            metadata: {\n              hasAttachments: row.attachment_count > 0,\n              hasLinks: linkCount > 0,\n              hasImages: imageCount > 0,\n              hasTodos: todoCount > 0,\n              hasCodeBlocks: codeBlockCount > 0,\n              hasTables: tableCount > 0,\n            },\n          };\n        })\n        .filter(Boolean) as any[];\n\n      return results;\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Extract file metadata from database record\n   */\n  private extractFileMetadata(file: any): any {\n    return {\n      creationDate: CoreDataUtils.toDate(file.ZCREATIONDATE),\n      modificationDate: CoreDataUtils.toDate(file.ZMODIFICATIONDATE),\n      fileSize: file.ZFILESIZE || 0,\n      filePath: file.ZFILEPATH || '',\n      originalFilename: file.ZFILENAME || '',\n      // Add more metadata fields as available in the database\n    };\n  }\n\n  /**\n   * Analyze content patterns in notes\n   */\n  private analyzeContent(texts: string[]): any {\n    const analysis = {\n      markdownUsage: {\n        headings: 0,\n        lists: 0,\n        codeBlocks: 0,\n        links: 0,\n        images: 0,\n        tables: 0,\n      },\n      languagePatterns: [] as Array<{ language: string; count: number }>,\n      commonPatterns: [] as Array<{ pattern: string; description: string; count: number }>,\n    };\n\n    const languageMap = new Map<string, number>();\n    const patternCounts = {\n      emails: 0,\n      urls: 0,\n      phoneNumbers: 0,\n      dates: 0,\n      times: 0,\n      hashtags: 0,\n    };\n\n    texts.forEach(text => {\n      // Markdown usage\n      analysis.markdownUsage.headings += (text.match(/^#+\\s/gm) || []).length;\n      analysis.markdownUsage.lists += (text.match(/^[\\s]*[-*+]\\s/gm) || []).length;\n      analysis.markdownUsage.codeBlocks += (text.match(/```/g) || []).length / 2;\n      analysis.markdownUsage.links += (text.match(/\\[.*?\\]\\(.*?\\)/g) || []).length;\n      analysis.markdownUsage.images += (text.match(/!\\[.*?\\]\\(.*?\\)/g) || []).length;\n      analysis.markdownUsage.tables += (text.match(/\\|.*\\|/g) || []).length;\n\n      // Language detection (basic)\n      const codeBlocks = text.match(/```(\\w+)?\\n([\\s\\S]*?)```/g) || [];\n      codeBlocks.forEach(block => {\n        const match = block.match(/```(\\w+)/);\n        if (match && match[1]) {\n          const lang = match[1].toLowerCase();\n          languageMap.set(lang, (languageMap.get(lang) || 0) + 1);\n        }\n      });\n\n      // Common patterns\n      patternCounts.emails += (\n        text.match(/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g) || []\n      ).length;\n      patternCounts.urls += (text.match(/https?:\\/\\/[^\\s\\)]+/g) || []).length;\n      patternCounts.phoneNumbers += (text.match(/\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g) || []).length;\n      patternCounts.dates += (text.match(/\\b\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}\\b/g) || []).length;\n      patternCounts.times += (\n        text.match(/\\b\\d{1,2}:\\d{2}(?::\\d{2})?\\s?(?:AM|PM|am|pm)?\\b/g) || []\n      ).length;\n      patternCounts.hashtags += (text.match(/#\\w+/g) || []).length;\n    });\n\n    analysis.languagePatterns = Array.from(languageMap.entries())\n      .map(([language, count]) => ({ language, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    analysis.commonPatterns = [\n      { pattern: 'emails', description: 'Email addresses', count: patternCounts.emails },\n      { pattern: 'urls', description: 'Web URLs', count: patternCounts.urls },\n      { pattern: 'phoneNumbers', description: 'Phone numbers', count: patternCounts.phoneNumbers },\n      { pattern: 'dates', description: 'Date patterns', count: patternCounts.dates },\n      { pattern: 'times', description: 'Time patterns', count: patternCounts.times },\n      { pattern: 'hashtags', description: 'Hashtags', count: patternCounts.hashtags },\n    ]\n      .filter(p => p.count > 0)\n      .sort((a, b) => b.count - a.count);\n\n    return analysis;\n  }\n\n  /**\n   * Analyze links in notes\n   */\n  private analyzeLinks(texts: string[]): any {\n    const analysis = {\n      internalLinks: 0,\n      externalLinks: 0,\n      brokenLinks: 0,\n      topDomains: [] as Array<{ domain: string; count: number }>,\n      linkTypes: [] as Array<{ type: string; count: number }>,\n    };\n\n    const domainMap = new Map<string, number>();\n    const typeMap = new Map<string, number>();\n\n    texts.forEach(text => {\n      // Extract all URLs\n      const urls = text.match(/https?:\\/\\/[^\\s\\)\\]]+/g) || [];\n\n      urls.forEach(url => {\n        try {\n          const urlObj = new URL(url);\n          const domain = urlObj.hostname;\n\n          domainMap.set(domain, (domainMap.get(domain) || 0) + 1);\n\n          // Categorize link types\n          if (domain.includes('github.com')) {\n            typeMap.set('GitHub', (typeMap.get('GitHub') || 0) + 1);\n          } else if (domain.includes('stackoverflow.com')) {\n            typeMap.set('Stack Overflow', (typeMap.get('Stack Overflow') || 0) + 1);\n          } else if (domain.includes('wikipedia.org')) {\n            typeMap.set('Wikipedia', (typeMap.get('Wikipedia') || 0) + 1);\n          } else if (domain.includes('youtube.com') || domain.includes('youtu.be')) {\n            typeMap.set('YouTube', (typeMap.get('YouTube') || 0) + 1);\n          } else if (domain.includes('medium.com')) {\n            typeMap.set('Medium', (typeMap.get('Medium') || 0) + 1);\n          } else {\n            typeMap.set('Other', (typeMap.get('Other') || 0) + 1);\n          }\n\n          analysis.externalLinks++;\n        } catch (e) {\n          analysis.brokenLinks++;\n        }\n      });\n\n      // Bear internal links (bear:// protocol or [[Note Title]] format)\n      const internalLinks =\n        text.match(/(?:bear:\\/\\/|x-callback-url:\\/\\/bear|bear-callback:\\/\\/|\\[\\[.*?\\]\\])/g) || [];\n      analysis.internalLinks += internalLinks.length;\n    });\n\n    analysis.topDomains = Array.from(domainMap.entries())\n      .map(([domain, count]) => ({ domain, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    analysis.linkTypes = Array.from(typeMap.entries())\n      .map(([type, count]) => ({ type, count }))\n      .sort((a, b) => b.count - a.count);\n\n    return analysis;\n  }\n\n  /**\n   * Analyze note structure patterns\n   */\n  private analyzeStructure(notes: Array<{ title: string; text: string }>): any {\n    const analysis = {\n      titlePatterns: [] as Array<{ pattern: string; count: number; examples: string[] }>,\n      averageWordsPerNote: 0,\n      averageParagraphsPerNote: 0,\n      notesWithTodos: 0,\n      notesWithDates: 0,\n      notesWithNumbers: 0,\n    };\n\n    const titlePatternMap = new Map<string, { count: number; examples: string[] }>();\n    let totalWords = 0;\n    let totalParagraphs = 0;\n\n    notes.forEach(note => {\n      const { title, text } = note;\n\n      // Analyze title patterns\n      if (title) {\n        const patterns = this.extractTitlePatterns(title);\n        patterns.forEach(pattern => {\n          if (!titlePatternMap.has(pattern)) {\n            titlePatternMap.set(pattern, { count: 0, examples: [] });\n          }\n          const entry = titlePatternMap.get(pattern)!;\n          entry.count++;\n          if (entry.examples.length < 3) {\n            entry.examples.push(title);\n          }\n        });\n      }\n\n      // Count words and paragraphs\n      const words = text.split(/\\s+/).filter(word => word.length > 0);\n      totalWords += words.length;\n\n      const paragraphs = text.split(/\\n\\s*\\n/).filter(p => p.trim().length > 0);\n      totalParagraphs += paragraphs.length;\n\n      // Check for specific content types\n      if (text.match(/- \\[[ x]\\]/)) {\n        analysis.notesWithTodos++;\n      }\n      if (text.match(/\\b\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}\\b/)) {\n        analysis.notesWithDates++;\n      }\n      if (text.match(/\\b\\d+\\b/)) {\n        analysis.notesWithNumbers++;\n      }\n    });\n\n    analysis.titlePatterns = Array.from(titlePatternMap.entries())\n      .map(([pattern, data]) => ({ pattern, count: data.count, examples: data.examples }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    analysis.averageWordsPerNote = Math.round(totalWords / notes.length);\n    analysis.averageParagraphsPerNote = Math.round((totalParagraphs / notes.length) * 100) / 100;\n\n    return analysis;\n  }\n\n  /**\n   * Extract patterns from note titles\n   */\n  private extractTitlePatterns(title: string): string[] {\n    const patterns: string[] = [];\n\n    // Date patterns\n    if (title.match(/\\d{4}-\\d{2}-\\d{2}/)) {\n      patterns.push('ISO Date (YYYY-MM-DD)');\n    }\n    if (title.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}/)) {\n      patterns.push('US Date (MM/DD/YYYY)');\n    }\n    if (title.match(/\\d{1,2}-\\d{1,2}-\\d{2,4}/)) {\n      patterns.push('Dash Date (MM-DD-YYYY)');\n    }\n\n    // Meeting patterns\n    if (title.toLowerCase().includes('meeting')) {\n      patterns.push('Meeting Notes');\n    }\n    if (title.toLowerCase().includes('standup')) {\n      patterns.push('Standup Notes');\n    }\n    if (title.toLowerCase().includes('interview')) {\n      patterns.push('Interview Notes');\n    }\n\n    // Project patterns\n    if (title.toLowerCase().includes('project')) {\n      patterns.push('Project Notes');\n    }\n    if (title.toLowerCase().includes('todo') || title.toLowerCase().includes('task')) {\n      patterns.push('Task Lists');\n    }\n\n    // Learning patterns\n    if (title.toLowerCase().includes('notes on') || title.toLowerCase().includes('learning')) {\n      patterns.push('Learning Notes');\n    }\n    if (title.toLowerCase().includes('tutorial') || title.toLowerCase().includes('guide')) {\n      patterns.push('Tutorials/Guides');\n    }\n\n    // Question patterns\n    if (title.startsWith('How to') || title.startsWith('Why') || title.startsWith('What')) {\n      patterns.push('Question Format');\n    }\n\n    // Number patterns\n    if (title.match(/^\\d+\\.?\\s/)) {\n      patterns.push('Numbered Title');\n    }\n\n    // Capitalization patterns\n    if (title === title.toUpperCase()) {\n      patterns.push('ALL CAPS');\n    }\n    if (title.split(' ').every(word => word[0] === word[0].toUpperCase())) {\n      patterns.push('Title Case');\n    }\n\n    return patterns.length > 0 ? patterns : ['No Pattern'];\n  }\n\n  /**\n   * Create a new note with title, content, and tags\n   * Note: Bear automatically extracts the title from the first line of content (markdown header).\n   * We don't set ZTITLE directly to avoid inconsistencies between database and Bear's display.\n   */\n  async createNote(options: {\n    title: string;\n    content?: string;\n    tags?: string[];\n    isArchived?: boolean;\n    isPinned?: boolean;\n  }): Promise<{ noteId: string; success: boolean; tagWarnings?: string[] }> {\n    // Validate and sanitize tags first\n    const tagValidation = this.validateAndSanitizeTags(options.tags || []);\n    const sanitizedTags = tagValidation.sanitized;\n    const tagWarnings = tagValidation.warnings;\n\n    try {\n      const { exec } = await import('child_process');\n      const { promisify } = await import('util');\n      const execAsync = promisify(exec);\n\n      // Build the content (tags will be handled via API parameter)\n      let noteContent = '';\n\n      // Add content only (no hashtags - API will handle tags)\n      if (options.content) {\n        noteContent = options.content;\n\n        // CRITICAL FIX: Remove duplicate title headers from content\n        // If content starts with a markdown header that matches the title, remove it\n        const titleHeaderPattern = new RegExp(\n          `^#\\\\s+${options.title.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n+`,\n          'i'\n        );\n        if (titleHeaderPattern.test(noteContent)) {\n          noteContent = noteContent.replace(titleHeaderPattern, '');\n        }\n      }\n\n      // Create the Bear URL with proper encoding\n      const encodedTitle = encodeURIComponent(options.title);\n      const encodedContent = encodeURIComponent(noteContent);\n      const encodedTags = encodeURIComponent(sanitizedTags.join(','));\n\n      // Build Bear API URL\n      let bearURL = `bear://x-callback-url/create?title=${encodedTitle}`;\n\n      if (noteContent) {\n        bearURL += `&text=${encodedContent}`;\n      }\n\n      if (sanitizedTags.length > 0) {\n        bearURL += `&tags=${encodedTags}`;\n      }\n\n      if (options.isPinned) {\n        bearURL += `&pin=yes`;\n      }\n\n      // Note: Bear API doesn't directly support creating archived notes\n      // We'll create the note normally and archive it separately if needed\n\n      // Execute the Bear API call\n      await execAsync(`open \"${bearURL}\"`);\n\n      // Wait for Bear to process the creation\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // If the note should be archived, we'll need to find it and archive it\n      // This is a limitation of Bear's current API\n      const noteId = 'created-via-api'; // We can't get the actual ID from the create API\n\n      if (options.isArchived) {\n        // TODO: Implement archiving after creation once we can reliably find the new note\n        // For now, we'll note this in the response\n      }\n\n      return {\n        noteId,\n        success: true,\n        tagWarnings: tagWarnings.length > 0 ? tagWarnings : undefined,\n      };\n    } catch (error) {\n      throw new Error(\n        `Failed to create note via sync-safe Bear API: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Update an existing note\n   * Note: Title changes are handled by updating the content's first line (markdown header).\n   * We clear ZTITLE so Bear will re-extract it from the updated content.\n   */\n  async updateNote(\n    noteId: number,\n    options: {\n      title?: string;\n      content?: string;\n      tags?: string[];\n      isArchived?: boolean;\n      isPinned?: boolean;\n      expectedModificationDate?: Date;\n    }\n  ): Promise<{ success: boolean; conflictDetected?: boolean; tagWarnings?: string[] }> {\n    // Validate and sanitize tags if provided\n    let sanitizedTags: string[] | undefined;\n    let tagWarnings: string[] = [];\n\n    if (options.tags !== undefined) {\n      const tagValidation = this.validateAndSanitizeTags(options.tags);\n      sanitizedTags = tagValidation.sanitized;\n      tagWarnings = tagValidation.warnings;\n    }\n\n    try {\n      // First, read the current note from database to get ZUNIQUEIDENTIFIER\n      await this.database.connect(true); // Read mode\n\n      const [currentNote] = await this.database.query<{\n        ZUNIQUEIDENTIFIER: string;\n        ZMODIFICATIONDATE: number;\n        ZTITLE: string;\n        ZTEXT: string;\n      }>(\n        `\n        SELECT ZUNIQUEIDENTIFIER, ZMODIFICATIONDATE, ZTITLE, ZTEXT \n        FROM ZSFNOTE \n        WHERE Z_PK = ? AND ZTRASHED = 0\n      `,\n        [noteId]\n      );\n\n      if (!currentNote) {\n        throw new Error(`Note with ID ${noteId} not found or is trashed`);\n      }\n\n      // Conflict detection\n      if (options.expectedModificationDate) {\n        const currentModDate = CoreDataUtils.toDate(currentNote.ZMODIFICATIONDATE);\n        if (\n          Math.abs(currentModDate.getTime() - options.expectedModificationDate.getTime()) > 1000\n        ) {\n          return {\n            success: false,\n            conflictDetected: true,\n            tagWarnings: tagWarnings.length > 0 ? tagWarnings : undefined,\n          };\n        }\n      }\n\n      await this.database.disconnect();\n\n      // Use Bear API for sync-safe updates\n      const { exec } = await import('child_process');\n      const { promisify } = await import('util');\n      const execAsync = promisify(exec);\n\n      // Build the new content\n      let noteContent = '';\n\n      // Handle title and content updates\n      if (options.title !== undefined || options.content !== undefined) {\n        if (options.content !== undefined) {\n          noteContent = options.content;\n\n          // CRITICAL FIX: Remove duplicate title headers from content during updates\n          // This prevents duplicate titles when Claude sends content with markdown headers\n          const titleToCheck = options.title !== undefined ? options.title : currentNote.ZTITLE;\n          if (titleToCheck) {\n            const titleHeaderPattern = new RegExp(\n              `^#\\\\s+${titleToCheck.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n+`,\n              'i'\n            );\n            if (titleHeaderPattern.test(noteContent)) {\n              noteContent = noteContent.replace(titleHeaderPattern, '');\n            }\n          }\n        } else {\n          // If only title is being updated, preserve existing content (minus old title)\n          const existingContent = currentNote.ZTEXT || '';\n          const contentWithoutTitle = existingContent.replace(/^# .+?\\n\\n?/m, '');\n          noteContent = contentWithoutTitle;\n        }\n      } else {\n        // No content/title updates, preserve existing content\n        noteContent = currentNote.ZTEXT || '';\n\n        // CRITICAL FIX: Even for tags-only updates, remove duplicate title headers\n        // This prevents duplicate titles when Claude adds tags to notes with existing headers\n        if (currentNote.ZTITLE) {\n          const titleHeaderPattern = new RegExp(\n            `^#\\\\s+${currentNote.ZTITLE.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n+`,\n            'i'\n          );\n          if (titleHeaderPattern.test(noteContent)) {\n            noteContent = noteContent.replace(titleHeaderPattern, '');\n          }\n        }\n      }\n\n      // Note: Tags will be handled via API parameter, not embedded in content\n\n      // Create the Bear URL with proper encoding\n      const encodedId = encodeURIComponent(currentNote.ZUNIQUEIDENTIFIER);\n      const encodedContent = encodeURIComponent(noteContent);\n\n      // Build Bear API URL for updating\n      let bearURL = `bear://x-callback-url/add-text?id=${encodedId}&mode=replace&text=${encodedContent}`;\n\n      if (options.title !== undefined) {\n        const encodedTitle = encodeURIComponent(options.title);\n        bearURL += `&title=${encodedTitle}`;\n      }\n\n      if (sanitizedTags !== undefined && sanitizedTags.length > 0) {\n        const encodedTags = encodeURIComponent(sanitizedTags.join(','));\n        bearURL += `&tags=${encodedTags}`;\n      }\n\n      if (options.isPinned !== undefined) {\n        bearURL += `&pin=${options.isPinned ? 'yes' : 'no'}`;\n      }\n\n      // Note: Bear API doesn't directly support archiving in add-text\n      // We'll handle archiving separately if needed\n\n      // Execute the Bear API call\n      await execAsync(`open \"${bearURL}\"`);\n\n      // Wait for Bear to process the update\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Handle archiving separately if needed (limitation of Bear API)\n      if (options.isArchived !== undefined) {\n        // TODO: Implement archiving via separate API call once available\n      }\n\n      return {\n        success: true,\n        tagWarnings: tagWarnings.length > 0 ? tagWarnings : undefined,\n      };\n    } catch (error) {\n      await this.database.disconnect();\n      throw new Error(\n        `Failed to update note via sync-safe Bear API: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Duplicate an existing note\n   */\n  async duplicateNote(\n    noteId: number,\n    options: {\n      titleSuffix?: string;\n      copyTags?: boolean;\n    } = {}\n  ): Promise<{ newNoteId: string; success: boolean }> {\n    await this.database.connect(true); // Read mode first\n\n    try {\n      // Get the source note\n      const [sourceNote] = await this.database.query<BearNote>(\n        `\n        SELECT * FROM ZSFNOTE WHERE Z_PK = ? AND ZTRASHED = 0\n      `,\n        [noteId]\n      );\n\n      if (!sourceNote) {\n        throw new Error(`Note with ID ${noteId} not found or is trashed`);\n      }\n\n      // Get tags if copying them\n      let tags: string[] = [];\n      if (options.copyTags !== false) {\n        const tagResults = await this.database.query<{ ZTITLE: string }>(\n          `\n          SELECT t.ZTITLE\n          FROM ZSFNOTETAG t\n          INNER JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS\n          WHERE nt.Z_5NOTES = ?\n        `,\n          [noteId]\n        );\n        tags = tagResults.map(t => t.ZTITLE);\n      }\n\n      await this.database.disconnect();\n\n      // Create the duplicate note\n      const newTitle = sourceNote.ZTITLE + (options.titleSuffix || ' (Copy)');\n\n      const result = await this.createNote({\n        title: newTitle,\n        content: sourceNote.ZTEXT || '',\n        tags,\n        isArchived: sourceNote.ZARCHIVED === 1,\n        isPinned: sourceNote.ZPINNED === 1,\n      });\n\n      return {\n        newNoteId: result.noteId,\n        success: result.success,\n      };\n    } catch (error) {\n      await this.database.disconnect();\n      throw new Error(\n        `Failed to duplicate note: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Archive or unarchive a note using sync-safe Bear API\n   */\n  async archiveNote(noteId: number, archived: boolean): Promise<{ success: boolean }> {\n    const result = await this.updateNote(noteId, {\n      isArchived: archived,\n    });\n\n    return {\n      success: result.success,\n    };\n  }\n\n  /**\n   * Generate a UUID for new notes (Bear format)\n   */\n  private generateUUID(): string {\n    // Generate a UUID v4 format that Bear uses\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n      const r = (Math.random() * 16) | 0;\n      const v = c == 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * Clear Bear's Core Data cache to force sidebar refresh\n   */\n  private async clearBearCache(): Promise<void> {\n    try {\n      await this.database.query(`DELETE FROM Z_MODELCACHE`);\n    } catch (error) {\n      // Cache clearing is optional - don't fail the operation if it doesn't work\n      // Silent error handling to avoid JSON-RPC interference\n    }\n  }\n\n  /**\n   * Trigger Bear to reparse a note by simulating a content edit\n   * This mimics the manual edit that makes Bear recognize hashtags\n   */\n  private async triggerBearReparse(noteId: number): Promise<void> {\n    try {\n      // Get current content\n      const currentNote = await this.database.queryOne<{ ZTEXT: string }>(\n        `\n        SELECT ZTEXT FROM ZSFNOTE WHERE Z_PK = ?\n      `,\n        [noteId]\n      );\n\n      if (!currentNote) {\n        return;\n      }\n\n      // Simulate a content edit by adding and removing a character\n      // This mimics what happens when you type and delete in Bear\n      const originalContent = currentNote.ZTEXT || '';\n      const tempContent = `${originalContent} `; // Add a space\n\n      // First update: add the space\n      let now = CoreDataUtils.fromDate(new Date());\n      await this.database.query(\n        `\n        UPDATE ZSFNOTE \n        SET ZTEXT = ?, ZMODIFICATIONDATE = ?, ZVERSION = COALESCE(ZVERSION, 0) + 1\n        WHERE Z_PK = ?\n      `,\n        [tempContent, now, noteId]\n      );\n\n      // Wait a moment\n      await new Promise(resolve => setTimeout(resolve, 50));\n\n      // Second update: remove the space (back to original)\n      now = CoreDataUtils.fromDate(new Date());\n      await this.database.query(\n        `\n        UPDATE ZSFNOTE \n        SET ZTEXT = ?, ZMODIFICATIONDATE = ?, ZVERSION = COALESCE(ZVERSION, 0) + 1\n        WHERE Z_PK = ?\n      `,\n        [originalContent, now, noteId]\n      );\n    } catch (error) {\n      // Silent error handling to avoid JSON-RPC interference\n    }\n  }\n\n  /**\n   * Validate and sanitize tag names according to Bear's rules\n   * Bear tag rules:\n   * - No capital letters (converts to lowercase)\n   * - No hyphens (removes them)\n   * - No spaces (removes them)\n   * - Underscores allowed (kept as-is)\n   * - No commas (removes them)\n   * - Forward slashes allowed for nested tags (e.g., project/alpha)\n   * - Must not be empty after sanitization\n   */\n  private validateAndSanitizeTags(tags: string[]): {\n    sanitized: string[];\n    warnings: string[];\n  } {\n    const sanitized: string[] = [];\n    const warnings: string[] = [];\n\n    for (const originalTag of tags) {\n      const trimmed = originalTag.trim();\n\n      if (!trimmed) {\n        warnings.push(`Empty tag ignored`);\n        continue;\n      }\n\n      let sanitizedTag = trimmed;\n      let hadChanges = false;\n\n      // Convert to lowercase\n      if (sanitizedTag !== sanitizedTag.toLowerCase()) {\n        sanitizedTag = sanitizedTag.toLowerCase();\n        hadChanges = true;\n      }\n\n      // Remove hyphens\n      if (sanitizedTag.includes('-')) {\n        sanitizedTag = sanitizedTag.replace(/-/g, '');\n        hadChanges = true;\n      }\n\n      // Remove spaces\n      if (sanitizedTag.includes(' ')) {\n        sanitizedTag = sanitizedTag.replace(/\\s+/g, '');\n        hadChanges = true;\n      }\n\n      // Keep underscores (they are allowed in Bear tags)\n      // No processing needed for underscores\n\n      // Remove commas\n      if (sanitizedTag.includes(',')) {\n        sanitizedTag = sanitizedTag.replace(/,/g, '');\n        hadChanges = true;\n      }\n\n      // Clean up multiple slashes and remove leading/trailing slashes\n      sanitizedTag = sanitizedTag\n        .replace(/\\/+/g, '/') // Multiple slashes to single\n        .replace(/^\\/+|\\/+$/g, ''); // Remove leading/trailing slashes\n\n      // Check if tag is still valid after sanitization\n      if (!sanitizedTag) {\n        warnings.push(`Tag \"${originalTag}\" became empty after sanitization and was ignored`);\n        continue;\n      }\n\n      // Add to results\n      sanitized.push(sanitizedTag);\n\n      // Add warning if changes were made\n      if (hadChanges) {\n        warnings.push(`Tag \"${originalTag}\" was sanitized to \"${sanitizedTag}\"`);\n      }\n    }\n\n    return { sanitized, warnings };\n  }\n\n  /**\n   * Legacy method kept for backward compatibility\n   * @deprecated Use validateAndSanitizeTags instead\n   */\n  private sanitizeTagName(tagName: string): string {\n    const result = this.validateAndSanitizeTags([tagName]);\n    return result.sanitized[0] || '';\n  }\n\n  /**\n   * Most effective method to trigger Bear's hashtag parsing\n   * Uses Bear's API to update the note with its own content, forcing a reparse\n   */\n  private async triggerBearParseEffectively(\n    noteUUID: string,\n    noteContent: string,\n    noteTitle?: string\n  ): Promise<void> {\n    try {\n      const { exec } = await import('child_process');\n      const { promisify } = await import('util');\n      const execAsync = promisify(exec);\n\n      // CRITICAL FIX: Remove duplicate title headers before triggering reparse\n      // This prevents duplicate titles when hashtag parsing updates notes with existing headers\n      let processedContent = noteContent;\n      if (noteTitle) {\n        const titleHeaderPattern = new RegExp(\n          `^#\\\\s+${noteTitle.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n+`,\n          'i'\n        );\n        if (titleHeaderPattern.test(processedContent)) {\n          processedContent = processedContent.replace(titleHeaderPattern, '');\n        }\n      }\n\n      // Use Bear's API to replace the note content with itself\n      // This forces Bear to reparse all hashtags in the content\n      const encodedContent = encodeURIComponent(processedContent);\n      const bearURL = `bear://x-callback-url/add-text?id=${noteUUID}&mode=replace&text=${encodedContent}&show_window=no`;\n\n      await execAsync(`open \"${bearURL}\"`);\n\n      // Wait for Bear to process the update and reparse hashtags\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    } catch (error) {\n      throw new Error(\n        `Failed to trigger effective Bear parsing: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Public method to trigger hashtag parsing for a specific note\n   * Can be called by MCP tools to help users fix sidebar display issues\n   * Note: Bear must be running for this to work effectively\n   */\n  async triggerHashtagParsing(noteId?: string, noteTitle?: string): Promise<string> {\n    if (!noteId && !noteTitle) {\n      throw new Error('Either noteId or noteTitle is required');\n    }\n\n    // Check if Bear is running\n    const isBearRunning = await this.isBearRunning();\n    if (!isBearRunning) {\n      return `Bear is not running. Please start Bear first, then the hashtags will be parsed automatically. Alternatively, restart Bear to trigger parsing for all notes.`;\n    }\n\n    try {\n      await this.database.connect(true); // Read mode\n\n      // Find the note\n      let query: string;\n      let params: any[];\n\n      if (noteId) {\n        query =\n          'SELECT Z_PK, ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT FROM ZSFNOTE WHERE ZUNIQUEIDENTIFIER = ? AND ZTRASHED = 0';\n        params = [noteId];\n      } else {\n        query =\n          'SELECT Z_PK, ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT FROM ZSFNOTE WHERE ZTITLE = ? AND ZTRASHED = 0';\n        params = [noteTitle];\n      }\n\n      const note = await this.database.queryOne<{\n        Z_PK: number;\n        ZUNIQUEIDENTIFIER: string;\n        ZTITLE: string;\n        ZTEXT: string;\n      }>(query, params);\n\n      if (!note) {\n        throw new Error(`Note not found: ${noteId || noteTitle}`);\n      }\n\n      // Most effective approach: Use Bear's API to \"update\" the note with its own content\n      // This forces Bear to reparse all hashtags in the content\n      await this.triggerBearParseEffectively(note.ZUNIQUEIDENTIFIER, note.ZTEXT, note.ZTITLE);\n\n      return `Hashtag parsing triggered for note: ${noteId || noteTitle}. Bear should update the sidebar within a few seconds.`;\n    } catch (error) {\n      throw new Error(\n        `Failed to trigger hashtag parsing: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    } finally {\n      await this.database.disconnect();\n    }\n  }\n\n  /**\n   * Create a note using Bear's x-callback-url API when Bear is running\n   * This bypasses database writes and uses Bear's native API instead\n   */\n  async createNoteViaBearAPI(title: string, content: string, tags: string[]): Promise<string> {\n    try {\n      const { exec } = await import('child_process');\n      const { promisify } = await import('util');\n      const execAsync = promisify(exec);\n\n      // Validate and sanitize tags according to Bear's rules\n      const tagValidation = this.validateAndSanitizeTags(tags);\n      const sanitizedTags = tagValidation.sanitized;\n\n      // Build the content with embedded hashtags in Bear format (no title header since Bear API handles title separately)\n      const hashtagsLine = sanitizedTags.map(tag => `#${tag}`).join(' ');\n      let bearContent = '';\n\n      // Add hashtags line if there are tags\n      if (hashtagsLine) {\n        bearContent += `${hashtagsLine}\\n\\n`;\n      }\n\n      // Add the actual content\n      if (content) {\n        // CRITICAL FIX: Remove duplicate title headers from content\n        // This prevents duplicate titles when content includes headers matching the title\n        let processedContent = content;\n        const titleHeaderPattern = new RegExp(\n          `^#\\\\s+${title.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n+`,\n          'i'\n        );\n        if (titleHeaderPattern.test(processedContent)) {\n          processedContent = processedContent.replace(titleHeaderPattern, '');\n        }\n        bearContent += processedContent;\n      }\n\n      // Create the Bear URL with proper encoding\n      const encodedTitle = encodeURIComponent(title);\n      const encodedContent = encodeURIComponent(bearContent);\n      const encodedTags = encodeURIComponent(sanitizedTags.join(','));\n\n      const bearURL = `bear://x-callback-url/create?title=${encodedTitle}&text=${encodedContent}&tags=${encodedTags}&edit=yes&show_window=no`;\n\n      // Creating note via Bear API (silent for JSON-RPC compatibility)\n      await execAsync(`open \"${bearURL}\"`);\n\n      // Wait for Bear to process the creation\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      return `Note \"${title}\" created via Bear API with tags: ${sanitizedTags.join(', ')}`;\n    } catch (error) {\n      throw new Error(\n        `Failed to create note via Bear API: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Batch trigger hashtag parsing for multiple notes\n   * Useful for fixing sidebar display issues for many notes at once\n   */\n  async batchTriggerHashtagParsing(options: {\n    tag_filter?: string;\n    title_pattern?: string;\n    limit?: number;\n    created_after?: string;\n  }): Promise<string> {\n    try {\n      await this.database.connect(true); // Read mode\n\n      // Build query to find notes\n      let query = 'SELECT Z_PK, ZUNIQUEIDENTIFIER, ZTITLE FROM ZSFNOTE WHERE ZTRASHED = 0';\n      const params: any[] = [];\n\n      if (options.title_pattern) {\n        query += ' AND ZTITLE LIKE ?';\n        params.push(`%${options.title_pattern}%`);\n      }\n\n      if (options.created_after) {\n        const date = new Date(options.created_after);\n        query += ' AND ZCREATIONDATE > ?';\n        params.push(CoreDataUtils.fromDate(date));\n      }\n\n      query += ' ORDER BY ZMODIFICATIONDATE DESC';\n\n      if (options.limit) {\n        query += ' LIMIT ?';\n        params.push(options.limit);\n      }\n\n      const notes = await this.database.query<{\n        Z_PK: number;\n        ZUNIQUEIDENTIFIER: string;\n        ZTITLE: string;\n      }>(query, params);\n\n      if (notes.length === 0) {\n        await this.database.disconnect();\n        return 'No notes found matching the criteria';\n      }\n\n      // Process each note\n      let successCount = 0;\n      for (const note of notes) {\n        try {\n          // Get the full note content for effective parsing trigger\n          const fullNote = await this.database.queryOne<{ ZTEXT: string }>(\n            `\n            SELECT ZTEXT FROM ZSFNOTE WHERE Z_PK = ?\n          `,\n            [note.Z_PK]\n          );\n\n          if (fullNote?.ZTEXT) {\n            await this.triggerBearParseEffectively(\n              note.ZUNIQUEIDENTIFIER,\n              fullNote.ZTEXT,\n              note.ZTITLE\n            );\n            successCount++;\n          }\n\n          // Small delay between notes to avoid overwhelming Bear\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } catch (error) {\n          // Silent error handling to avoid JSON-RPC interference\n        }\n      }\n\n      await this.database.disconnect();\n\n      return `Triggered hashtag parsing for ${successCount}/${notes.length} notes. Check Bear's sidebar in a few seconds.`;\n    } catch (error) {\n      throw new Error(\n        `Failed to batch trigger hashtag parsing: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n}\n", "#!/usr/bin/env node\n\n/**\n * Bear MCP Server\n * Copyright (c) 2024 Bear MCP Server\n * MIT License - see LICENSE file for details\n */\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  Tool,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { BearService } from './services/bear-service.js';\nimport { BearDatabaseError, BearSafetyError } from './types/bear.js';\n\n/**\n * Bear MCP Server\n * Provides MCP tools for interfacing with Bear's SQLite database\n */\nclass BearMCPServer {\n  private server: Server;\n  private bearService: BearService;\n\n  constructor() {\n    this.server = new Server({\n      name: 'bear-mcp-server',\n      version: '1.0.0',\n    });\n\n    this.bearService = new BearService();\n    this.setupHandlers();\n  }\n\n  private setupHandlers(): void {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: this.getAvailableTools(),\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async request => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case 'get_database_stats':\n            return await this.getDatabaseStats();\n\n          case 'get_database_schema':\n            return await this.getDatabaseSchema();\n\n          case 'check_bear_status':\n            return await this.checkBearStatus();\n\n          case 'verify_database_access':\n            return await this.verifyDatabaseAccess();\n\n          case 'create_backup':\n            return await this.createBackup();\n\n          case 'get_recent_notes':\n            return await this.getRecentNotes(args);\n\n          case 'search_notes':\n            return await this.searchNotes(args);\n\n          case 'get_note_by_id':\n            return await this.getNoteById(args);\n\n          case 'get_note_by_title':\n            return await this.getNoteByTitle(args);\n\n          case 'get_all_tags':\n            return await this.getAllTags();\n\n          case 'get_notes_by_tag':\n            return await this.getNotesByTag(args);\n\n          case 'get_notes_advanced':\n            return await this.getNotesAdvanced(args);\n\n          case 'get_notes_with_criteria':\n            return await this.getNotesWithCriteria(args);\n\n          case 'get_note_analytics':\n            return await this.getNoteAnalytics();\n\n          case 'get_related_notes':\n            return await this.getRelatedNotes(args);\n\n          case 'search_notes_fulltext':\n            return await this.searchNotesFullText(args);\n\n          case 'get_search_suggestions':\n            return await this.getSearchSuggestions(args);\n\n          case 'find_similar_notes':\n            return await this.findSimilarNotes(args);\n\n          // case 'search_notes_regex':\n          //   return await this.searchNotesRegex(args);\n\n          // TODO: Implement tag management methods in BearService\n          // case 'get_tag_hierarchy':\n          //   return await this.getTagHierarchy(args);\n\n          // case 'get_tag_analytics':\n          //   return await this.getTagAnalytics(args);\n\n          // case 'analyze_tag_relationships':\n          //   return await this.analyzeTagRelationships(args);\n\n          // case 'get_tag_usage_trends':\n          //   return await this.getTagUsageTrends(args);\n\n          case 'get_file_attachments':\n            return await this.getFileAttachments(args);\n\n          case 'analyze_note_metadata':\n            return await this.analyzeNoteMetadata(args);\n\n          case 'get_notes_with_metadata':\n            return await this.getNotesWithMetadata(args);\n\n          case 'create_note':\n            return await this.createNote(args);\n\n          case 'update_note':\n            return await this.updateNote(args);\n\n          case 'duplicate_note':\n            return await this.duplicateNote(args);\n\n          case 'archive_note':\n            return await this.archiveNote(args);\n\n          case 'trigger_hashtag_parsing':\n            return await this.triggerHashtagParsing(args);\n\n          case 'batch_trigger_hashtag_parsing':\n            return await this.batchTriggerHashtagParsing(args);\n\n          default:\n            throw new Error(`Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n        };\n      }\n    });\n  }\n\n  private getAvailableTools(): Tool[] {\n    return [\n      {\n        name: 'get_database_stats',\n        description:\n          'Get comprehensive statistics about the Bear database including note counts, tags, and database health',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'get_database_schema',\n        description: 'Retrieve the complete database schema showing all tables and their structure',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'check_bear_status',\n        description:\n          'Check if Bear app is currently running (informational - write operations now use sync-safe Bear API)',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'verify_database_access',\n        description: 'Verify that the Bear database is accessible and readable',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'create_backup',\n        description: 'Create a timestamped backup of the Bear database',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'get_recent_notes',\n        description: 'Get the most recently modified notes',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            limit: {\n              type: 'number',\n              description: 'Number of notes to retrieve (default: 10)',\n              minimum: 1,\n              maximum: 100,\n            },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'search_notes',\n        description: 'Search notes by title and content',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query to match against note titles and content',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results (default: 20)',\n              minimum: 1,\n              maximum: 100,\n            },\n          },\n          required: ['query'],\n        },\n      },\n      {\n        name: 'get_note_by_id',\n        description: 'Get a specific note by its database ID',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            id: {\n              type: 'number',\n              description: 'The database ID of the note',\n            },\n          },\n          required: ['id'],\n        },\n      },\n      {\n        name: 'get_note_by_title',\n        description: 'Get a specific note by its title',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            title: {\n              type: 'string',\n              description: 'The exact title of the note',\n            },\n          },\n          required: ['title'],\n        },\n      },\n      {\n        name: 'get_all_tags',\n        description: 'Get all tags with their usage counts',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'get_notes_by_tag',\n        description: 'Get all notes that have a specific tag',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tag: {\n              type: 'string',\n              description: 'The tag name to search for',\n            },\n          },\n          required: ['tag'],\n        },\n      },\n      {\n        name: 'get_notes_advanced',\n        description: 'Advanced note search with filtering, sorting, and pagination',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query for title and content',\n            },\n            tags: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Tags that notes must have (AND logic)',\n            },\n            excludeTags: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Tags to exclude from results',\n            },\n            sortBy: {\n              type: 'string',\n              enum: ['created', 'modified', 'title', 'size'],\n              description: 'Sort notes by field',\n            },\n            sortOrder: {\n              type: 'string',\n              enum: ['asc', 'desc'],\n              description: 'Sort order',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results',\n              minimum: 1,\n              maximum: 100,\n            },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'get_notes_with_criteria',\n        description: 'Find notes using complex criteria with AND/OR logic',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            titleContains: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Terms that must appear in title (OR logic)',\n            },\n            contentContains: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Terms that must appear in content (OR logic)',\n            },\n            hasAllTags: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Tags that notes must have (AND logic)',\n            },\n            hasAnyTags: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Tags that notes can have (OR logic)',\n            },\n            isPinned: {\n              type: 'boolean',\n              description: 'Filter by pinned status',\n            },\n            isArchived: {\n              type: 'boolean',\n              description: 'Filter by archived status',\n            },\n            minLength: {\n              type: 'number',\n              description: 'Minimum content length',\n            },\n            maxLength: {\n              type: 'number',\n              description: 'Maximum content length',\n            },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'get_note_analytics',\n        description: 'Get comprehensive analytics and statistics about notes',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: [],\n        },\n      },\n      {\n        name: 'get_related_notes',\n        description: 'Find notes related to a specific note by tags and content',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            noteId: {\n              type: 'number',\n              description: 'The ID of the note to find related notes for',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of related notes to return',\n              minimum: 1,\n              maximum: 20,\n            },\n          },\n          required: ['noteId'],\n        },\n      },\n      {\n        name: 'search_notes_fulltext',\n        description: 'Advanced full-text search with relevance scoring and snippets',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query string',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results',\n              minimum: 1,\n              maximum: 50,\n            },\n            includeSnippets: {\n              type: 'boolean',\n              description: 'Include content snippets around matches',\n            },\n            searchFields: {\n              type: 'array',\n              items: { type: 'string', enum: ['title', 'content', 'both'] },\n              description: 'Fields to search in',\n            },\n            fuzzyMatch: {\n              type: 'boolean',\n              description: 'Enable fuzzy matching for typos',\n            },\n            caseSensitive: {\n              type: 'boolean',\n              description: 'Case sensitive search',\n            },\n          },\n          required: ['query'],\n        },\n      },\n      {\n        name: 'get_search_suggestions',\n        description: 'Get auto-complete suggestions for search queries',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            partialQuery: {\n              type: 'string',\n              description: 'Partial search query for suggestions',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of suggestions',\n              minimum: 1,\n              maximum: 20,\n            },\n          },\n          required: ['partialQuery'],\n        },\n      },\n      {\n        name: 'find_similar_notes',\n        description: 'Find notes similar to given text using content analysis',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            referenceText: {\n              type: 'string',\n              description: 'Text to find similar notes for',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of similar notes',\n              minimum: 1,\n              maximum: 20,\n            },\n            minSimilarity: {\n              type: 'number',\n              description: 'Minimum similarity score (0.0 to 1.0)',\n              minimum: 0,\n              maximum: 1,\n            },\n            excludeNoteId: {\n              type: 'number',\n              description: 'Note ID to exclude from results',\n            },\n          },\n          required: ['referenceText'],\n        },\n      },\n      {\n        name: 'search_notes_regex',\n        description: 'Search notes using regular expressions',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            pattern: {\n              type: 'string',\n              description: 'Regular expression pattern',\n            },\n            flags: {\n              type: 'string',\n              description: 'Regex flags (e.g., \"gi\" for global case-insensitive)',\n            },\n            searchIn: {\n              type: 'string',\n              enum: ['title', 'content', 'both'],\n              description: 'Where to search for the pattern',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results',\n              minimum: 1,\n              maximum: 50,\n            },\n            includeContext: {\n              type: 'boolean',\n              description: 'Include context around matches',\n            },\n          },\n          required: ['pattern'],\n        },\n      },\n      {\n        name: 'get_tag_hierarchy',\n        description: 'Get comprehensive tag hierarchy and relationships',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n        },\n      },\n      {\n        name: 'get_tag_analytics',\n        description: 'Get detailed tag statistics and usage patterns',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n        },\n      },\n      {\n        name: 'analyze_tag_relationships',\n        description: 'Analyze tag relationships and suggest improvements',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n        },\n      },\n      {\n        name: 'get_tag_usage_trends',\n        description: 'Get tag usage timeline and trends',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tagName: {\n              type: 'string',\n              description: 'Specific tag to analyze (optional)',\n            },\n            months: {\n              type: 'number',\n              description: 'Number of months to analyze',\n              minimum: 1,\n              maximum: 24,\n            },\n          },\n        },\n      },\n      {\n        name: 'get_file_attachments',\n        description: 'Get comprehensive file attachment information',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            noteId: {\n              type: 'number',\n              description: 'Specific note ID to get attachments for',\n            },\n            fileType: {\n              type: 'string',\n              description: 'Filter by file extension (e.g., \"jpg\", \"pdf\")',\n            },\n            includeMetadata: {\n              type: 'boolean',\n              description: 'Include detailed file metadata',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of attachments to return',\n              minimum: 1,\n              maximum: 100,\n            },\n          },\n        },\n      },\n      {\n        name: 'analyze_note_metadata',\n        description: 'Analyze note metadata and content patterns',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            includeContentAnalysis: {\n              type: 'boolean',\n              description: 'Include markdown and content pattern analysis',\n            },\n            includeLinkAnalysis: {\n              type: 'boolean',\n              description: 'Include link analysis and domain statistics',\n            },\n            includeStructureAnalysis: {\n              type: 'boolean',\n              description: 'Include note structure and title pattern analysis',\n            },\n          },\n        },\n      },\n      {\n        name: 'get_notes_with_metadata',\n        description: 'Get notes filtered by metadata characteristics',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            hasAttachments: {\n              type: 'boolean',\n              description: 'Filter notes with/without attachments',\n            },\n            hasLinks: {\n              type: 'boolean',\n              description: 'Filter notes with/without external links',\n            },\n            hasImages: {\n              type: 'boolean',\n              description: 'Filter notes with/without images',\n            },\n            hasTodos: {\n              type: 'boolean',\n              description: 'Filter notes with/without todo items',\n            },\n            hasCodeBlocks: {\n              type: 'boolean',\n              description: 'Filter notes with/without code blocks',\n            },\n            hasTables: {\n              type: 'boolean',\n              description: 'Filter notes with/without tables',\n            },\n            minWordCount: {\n              type: 'number',\n              description: 'Minimum word count',\n              minimum: 1,\n            },\n            maxWordCount: {\n              type: 'number',\n              description: 'Maximum word count',\n              minimum: 1,\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results',\n              minimum: 1,\n              maximum: 100,\n            },\n          },\n        },\n      },\n      {\n        name: 'create_note',\n        description: 'Create a new note with title, content, and tags using sync-safe Bear API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            title: {\n              type: 'string',\n              description: 'Title of the new note',\n            },\n            content: {\n              type: 'string',\n              description: 'Content/body of the note (optional)',\n            },\n            tags: {\n              type: 'array',\n              items: { type: 'string' },\n              description:\n                'Array of tag names to apply to the note. Tags are automatically sanitized: lowercase only, no spaces/hyphens (underscores allowed, use forward slashes for nested tags like \"work/project\")',\n            },\n            isArchived: {\n              type: 'boolean',\n              description: 'Whether the note should be archived',\n            },\n            isPinned: {\n              type: 'boolean',\n              description: 'Whether the note should be pinned',\n            },\n          },\n          required: ['title'],\n        },\n      },\n      {\n        name: 'update_note',\n        description: 'Update an existing note using sync-safe Bear API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            noteId: {\n              type: 'number',\n              description: 'ID of the note to update',\n            },\n            title: {\n              type: 'string',\n              description: 'New title for the note',\n            },\n            content: {\n              type: 'string',\n              description: 'New content for the note',\n            },\n            tags: {\n              type: 'array',\n              items: { type: 'string' },\n              description:\n                'New array of tag names (replaces existing tags). Tags are automatically sanitized: lowercase only, no spaces/hyphens (underscores allowed, use forward slashes for nested tags like \"work/project\")',\n            },\n            isArchived: {\n              type: 'boolean',\n              description: 'Whether the note should be archived',\n            },\n            isPinned: {\n              type: 'boolean',\n              description: 'Whether the note should be pinned',\n            },\n          },\n          required: ['noteId'],\n        },\n      },\n      {\n        name: 'duplicate_note',\n        description: 'Create a duplicate of an existing note using sync-safe Bear API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            noteId: {\n              type: 'number',\n              description: 'ID of the note to duplicate',\n            },\n            titleSuffix: {\n              type: 'string',\n              description: 'Suffix to add to the duplicated note title (default: \" (Copy)\")',\n            },\n            copyTags: {\n              type: 'boolean',\n              description: 'Whether to copy tags from the original note (default: true)',\n            },\n          },\n          required: ['noteId'],\n        },\n      },\n      {\n        name: 'archive_note',\n        description: 'Archive or unarchive a note using sync-safe Bear API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            noteId: {\n              type: 'number',\n              description: 'ID of the note to archive/unarchive',\n            },\n            archived: {\n              type: 'boolean',\n              description: 'True to archive, false to unarchive',\n            },\n          },\n          required: ['noteId', 'archived'],\n        },\n      },\n      {\n        name: 'trigger_hashtag_parsing',\n        description: 'Trigger Bear to reparse hashtags in a note using sync-safe API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            note_id: {\n              type: 'string',\n              description: 'Note ID to trigger parsing for',\n            },\n            note_title: {\n              type: 'string',\n              description: 'Note title to trigger parsing for (alternative to note_id)',\n            },\n          },\n          oneOf: [{ required: ['note_id'] }, { required: ['note_title'] }],\n        },\n      },\n      {\n        name: 'batch_trigger_hashtag_parsing',\n        description: 'Trigger hashtag parsing for multiple notes using sync-safe API',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tag_filter: {\n              type: 'string',\n              description: 'Filter notes by tag name',\n            },\n            title_pattern: {\n              type: 'string',\n              description: 'Filter notes by title pattern',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of notes to process',\n            },\n            created_after: {\n              type: 'string',\n              description: 'Filter notes created after this date (ISO string)',\n            },\n          },\n        },\n      },\n    ];\n  }\n\n  private async getDatabaseStats() {\n    try {\n      const stats = await this.bearService.getDatabaseStats();\n      const integrity = await this.bearService.checkIntegrity();\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Bear Database Statistics:\n\uD83D\uDCCA Notes: ${stats.totalNotes} total (${stats.activeNotes} active, ${stats.trashedNotes} trashed, ${stats.archivedNotes} archived)\n\uD83D\uDD12 Encrypted Notes: ${stats.encryptedNotes}\n\uD83C\uDFF7\uFE0F  Tags: ${stats.totalTags}\n\uD83D\uDCCE Attachments: ${stats.totalAttachments}\n\uD83D\uDCBE Database Size: ${(stats.databaseSize / 1024 / 1024).toFixed(2)} MB\n\uD83D\uDCC5 Last Modified: ${stats.lastModified.toLocaleString()}\n\u2705 Database Integrity: ${integrity ? 'OK' : 'FAILED'}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting database stats: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getDatabaseSchema() {\n    try {\n      const schema = await this.bearService.getSchema();\n\n      const schemaText = schema\n        .map(\n          (table: { name: string; sql: string }) =>\n            `Table: ${table.name}\\n${table.sql || 'No schema available'}\\n`\n        )\n        .join('\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Bear Database Schema:\\n\\n${schemaText}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting schema: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async checkBearStatus() {\n    try {\n      const isRunning = await this.bearService.isBearRunning();\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Bear App Status: ${isRunning ? '\uD83D\uDD34 RUNNING' : '\uD83D\uDFE2 NOT RUNNING'}\n${isRunning ? '\u2705 Write operations use sync-safe Bear API' : '\u2705 All database operations available'}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error checking Bear status: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async verifyDatabaseAccess() {\n    try {\n      await this.bearService.verifyDatabaseAccess();\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: '\u2705 Database access verified successfully',\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Database access failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async createBackup() {\n    try {\n      const backupPath = await this.bearService.createBackup();\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u2705 Backup created successfully: ${backupPath}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Backup failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getRecentNotes(args: any) {\n    try {\n      const limit = args?.limit || 10;\n      const notes = await this.bearService.getRecentNotes(limit);\n\n      if (notes.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No notes found.',\n            },\n          ],\n        };\n      }\n\n      const notesList = notes\n        .map(note => {\n          const preview = note.ZTEXT ? `${note.ZTEXT.substring(0, 100)}...` : '';\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          return `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}**${tags}\\n   ${preview}`;\n        })\n        .join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Recent Notes (${notes.length}):\\n\\n${notesList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting recent notes: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async searchNotes(args: any) {\n    try {\n      const query = args?.query;\n      const limit = args?.limit || 20;\n\n      if (!query) {\n        throw new Error('Search query is required');\n      }\n\n      const notes = await this.bearService.searchNotes(query, { limit });\n\n      if (notes.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No notes found matching \"${query}\".`,\n            },\n          ],\n        };\n      }\n\n      const notesList = notes\n        .map(note => {\n          const preview = note.ZTEXT ? `${note.ZTEXT.substring(0, 100)}...` : '';\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          return `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}\\n   ${preview}`;\n        })\n        .join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Search Results for \"${query}\" (${notes.length}):\\n\\n${notesList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error searching notes: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNoteById(args: any) {\n    try {\n      const id = args?.id;\n\n      if (!id) {\n        throw new Error('Note ID is required');\n      }\n\n      const note = await this.bearService.getNoteById(id);\n\n      if (!note) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No note found with ID ${id}.`,\n            },\n          ],\n        };\n      }\n\n      const tags = note.tags.length > 0 ? `\\n\uD83C\uDFF7\uFE0F Tags: ${note.tags.join(', ')}` : '';\n      const content = note.ZTEXT || 'No content';\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}\\n\\n${content}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting note: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNoteByTitle(args: any) {\n    try {\n      const title = args?.title;\n\n      if (!title) {\n        throw new Error('Note title is required');\n      }\n\n      const note = await this.bearService.getNoteByTitle(title);\n\n      if (!note) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No note found with title \"${title}\".`,\n            },\n          ],\n        };\n      }\n\n      const tags = note.tags.length > 0 ? `\\n\uD83C\uDFF7\uFE0F Tags: ${note.tags.join(', ')}` : '';\n      const content = note.ZTEXT || 'No content';\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}\\n\\n${content}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting note: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getAllTags() {\n    try {\n      const tags = await this.bearService.getTags();\n\n      if (tags.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No tags found.',\n            },\n          ],\n        };\n      }\n\n      const tagsList = tags.map(tag => `\uD83C\uDFF7\uFE0F **${tag.ZTITLE}** (${tag.noteCount} notes)`).join('\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `All Tags (${tags.length}):\\n\\n${tagsList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting tags: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNotesByTag(args: any) {\n    try {\n      const tag = args?.tag;\n\n      if (!tag) {\n        throw new Error('Tag name is required');\n      }\n\n      const notes = await this.bearService.getNotesByTag(tag);\n\n      if (notes.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No notes found with tag \"${tag}\".`,\n            },\n          ],\n        };\n      }\n\n      const notesList = notes\n        .map(note => {\n          const preview = note.ZTEXT ? `${note.ZTEXT.substring(0, 100)}...` : '';\n          const otherTags = note.tags.filter(t => t !== tag);\n          const tagInfo = otherTags.length > 0 ? ` [+${otherTags.join(', ')}]` : '';\n          return `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tagInfo}\\n   ${preview}`;\n        })\n        .join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Notes with tag \"${tag}\" (${notes.length}):\\n\\n${notesList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting notes by tag: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNotesAdvanced(args: any) {\n    try {\n      const options = {\n        query: args?.query,\n        tags: args?.tags,\n        excludeTags: args?.excludeTags,\n        sortBy: args?.sortBy || 'modified',\n        sortOrder: args?.sortOrder || 'desc',\n        limit: args?.limit || 20,\n      };\n\n      const notes = await this.bearService.getNotesAdvanced(options);\n\n      if (notes.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No notes found matching the specified criteria.',\n            },\n          ],\n        };\n      }\n\n      const notesList = notes\n        .map(note => {\n          const preview = note.preview || (note.ZTEXT ? `${note.ZTEXT.substring(0, 100)}...` : '');\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          const length = note.contentLength ? ` (${note.contentLength} chars)` : '';\n          return `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}${length}\\n   ${preview}`;\n        })\n        .join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Advanced Search Results (${notes.length}):\\n\\n${notesList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error in advanced search: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNotesWithCriteria(args: any) {\n    try {\n      const criteria = {\n        titleContains: args?.titleContains,\n        contentContains: args?.contentContains,\n        hasAllTags: args?.hasAllTags,\n        hasAnyTags: args?.hasAnyTags,\n        isPinned: args?.isPinned,\n        isArchived: args?.isArchived,\n        minLength: args?.minLength,\n        maxLength: args?.maxLength,\n      };\n\n      const notes = await this.bearService.getNotesWithCriteria(criteria);\n\n      if (notes.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No notes found matching the specified criteria.',\n            },\n          ],\n        };\n      }\n\n      const notesList = notes\n        .map(note => {\n          const preview = note.ZTEXT ? `${note.ZTEXT.substring(0, 100)}...` : '';\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          const length = note.contentLength ? ` (${note.contentLength} chars)` : '';\n          const status = [];\n          if (note.ZPINNED) {\n            status.push('\uD83D\uDCCC');\n          }\n          if (note.ZARCHIVED) {\n            status.push('\uD83D\uDCE6');\n          }\n          if (note.ZENCRYPTED) {\n            status.push('\uD83D\uDD12');\n          }\n          const statusStr = status.length > 0 ? ` ${status.join('')}` : '';\n\n          return `\uD83D\uDCDD **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}${length}${statusStr}\\n   ${preview}`;\n        })\n        .join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Criteria Search Results (${notes.length}):\\n\\n${notesList}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error in criteria search: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNoteAnalytics() {\n    try {\n      const analytics = await this.bearService.getNoteAnalytics();\n\n      const monthlyData = analytics.notesPerMonth\n        .slice(0, 6)\n        .map(stat => `   ${stat.month}: ${stat.count} notes`)\n        .join('\\n');\n\n      const topTagsData = analytics.topTags\n        .slice(0, 8)\n        .map(tag => `   ${tag.tag}: ${tag.count} notes`)\n        .join('\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\uD83D\uDCCA **Bear Notes Analytics**\n\n**\uD83D\uDCC8 Overview:**\n\u2022 Total Notes: ${analytics.totalNotes}\n\u2022 Average Length: ${analytics.averageLength} characters\n\u2022 Longest Note: \"${analytics.longestNote.title}\" (${analytics.longestNote.length} chars)\n\u2022 Shortest Note: \"${analytics.shortestNote.title}\" (${analytics.shortestNote.length} chars)\n\n**\uD83D\uDCC5 Timeline:**\n\u2022 Most Recent: \"${analytics.mostRecentNote.title}\" (${analytics.mostRecentNote.date.toLocaleDateString()})\n\u2022 Oldest Note: \"${analytics.oldestNote.title}\" (${analytics.oldestNote.date.toLocaleDateString()})\n\n**\uD83D\uDCCA Content Analysis:**\n\u2022 Notes with Images: ${analytics.contentStats.hasImages}\n\u2022 Notes with Files: ${analytics.contentStats.hasFiles}  \n\u2022 Notes with Code: ${analytics.contentStats.hasSourceCode}\n\u2022 Notes with TODOs: ${analytics.contentStats.hasTodos}\n\n**\uD83D\uDCC8 Recent Activity (Notes per Month):**\n${monthlyData}\n\n**\uD83C\uDFF7\uFE0F Top Tags:**\n${topTagsData}`,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error getting analytics: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async getRelatedNotes(args: any) {\n    try {\n      const noteId = args?.noteId;\n      const limit = args?.limit || 5;\n\n      if (!noteId) {\n        throw new Error('Note ID is required');\n      }\n\n      const related = await this.bearService.getRelatedNotes(noteId, limit);\n\n      if (related.byTags.length === 0 && related.byContent.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No related notes found for note ID ${noteId}.`,\n            },\n          ],\n        };\n      }\n\n      let result = `\uD83D\uDD17 **Related Notes for ID ${noteId}**\\n\\n`;\n\n      if (related.byTags.length > 0) {\n        result += `**\uD83D\uDCCC Related by Tags (${related.byTags.length}):**\\n`;\n        related.byTags.forEach(note => {\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          result += `\u2022 **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}\\n`;\n        });\n        result += '\\n';\n      }\n\n      if (related.byContent.length > 0) {\n        result += `**\uD83D\uDCC4 Related by Content (${related.byContent.length}):**\\n`;\n        related.byContent.forEach(note => {\n          const tags = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';\n          result += `\u2022 **${note.ZTITLE || 'Untitled'}** (ID: ${note.Z_PK})${tags}\\n`;\n        });\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: result,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `\u274C Error finding related notes: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          },\n        ],\n      };\n    }\n  }\n\n  private async searchNotesFullText(args: any) {\n    try {\n      const {\n        query,\n        limit = 20,\n        includeSnippets = true,\n        searchFields = ['both'],\n        fuzzyMatch = false,\n        caseSensitive = false,\n      } = args;\n\n      const results = await this.bearService.searchNotesFullText(query, {\n        limit,\n        includeSnippets,\n        searchFields,\n        fuzzyMatch,\n        caseSensitive,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  query,\n                  totalFound: results.length,\n                  results: results.map(result => ({\n                    id: result.Z_PK,\n                    title: result.ZTITLE,\n                    content:\n                      result.ZTEXT?.substring(0, 500) +\n                      (result.ZTEXT && result.ZTEXT.length > 500 ? '...' : ''),\n                    tags: result.tags,\n                    createdAt: result.ZCREATIONDATE,\n                    modifiedAt: result.ZMODIFICATIONDATE,\n                    relevanceScore: result.relevanceScore,\n                    matchedTerms: result.matchedTerms,\n                    snippets: result.snippets,\n                    titleMatches: result.titleMatches,\n                    contentMatches: result.contentMatches,\n                  })),\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async getSearchSuggestions(args: any) {\n    try {\n      const { partialQuery, limit = 10 } = args;\n      const suggestions = await this.bearService.getSearchSuggestions(partialQuery, limit);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  partialQuery,\n                  suggestions,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async findSimilarNotes(args: any) {\n    try {\n      const { referenceText, limit = 10, minSimilarity = 0.1, excludeNoteId } = args;\n      const results = await this.bearService.findSimilarNotes(referenceText, {\n        limit,\n        minSimilarity,\n        excludeNoteId,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  referenceText:\n                    referenceText.substring(0, 200) + (referenceText.length > 200 ? '...' : ''),\n                  totalFound: results.length,\n                  similarNotes: results.map(result => ({\n                    id: result.Z_PK,\n                    title: result.ZTITLE,\n                    content:\n                      result.ZTEXT?.substring(0, 300) +\n                      (result.ZTEXT && result.ZTEXT.length > 300 ? '...' : ''),\n                    tags: result.tags,\n                    createdAt: result.ZCREATIONDATE,\n                    modifiedAt: result.ZMODIFICATIONDATE,\n                    similarityScore: result.similarityScore,\n                    commonKeywords: result.commonKeywords,\n                  })),\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async getFileAttachments(args: any) {\n    try {\n      const { noteId, fileType, includeMetadata = false, limit } = args;\n      const attachments = await this.bearService.getFileAttachments({\n        noteId,\n        fileType,\n        includeMetadata,\n        limit,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: attachments,\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async analyzeNoteMetadata(args: any) {\n    try {\n      const {\n        includeContentAnalysis = false,\n        includeLinkAnalysis = false,\n        includeStructureAnalysis = false,\n      } = args;\n\n      const analysis = await this.bearService.analyzeNoteMetadata({\n        includeContentAnalysis,\n        includeLinkAnalysis,\n        includeStructureAnalysis,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: analysis,\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async getNotesWithMetadata(args: any) {\n    try {\n      const criteria = {\n        hasAttachments: args.hasAttachments,\n        hasLinks: args.hasLinks,\n        hasImages: args.hasImages,\n        hasTodos: args.hasTodos,\n        hasCodeBlocks: args.hasCodeBlocks,\n        hasTables: args.hasTables,\n        minWordCount: args.minWordCount,\n        maxWordCount: args.maxWordCount,\n        limit: args.limit || 20,\n      };\n\n      const notes = await this.bearService.getNotesWithMetadata(criteria);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  totalFound: notes.length,\n                  notes: notes.map(note => ({\n                    id: note.Z_PK,\n                    title: note.ZTITLE,\n                    content:\n                      note.ZTEXT?.substring(0, 300) +\n                      (note.ZTEXT && note.ZTEXT.length > 300 ? '...' : ''),\n                    tags: note.tags,\n                    createdAt: note.ZCREATIONDATE,\n                    modifiedAt: note.ZMODIFICATIONDATE,\n                    wordCount: note.wordCount,\n                    attachmentCount: note.attachmentCount,\n                    linkCount: note.linkCount,\n                    imageCount: note.imageCount,\n                    todoCount: note.todoCount,\n                    codeBlockCount: note.codeBlockCount,\n                    tableCount: note.tableCount,\n                    metadata: note.metadata,\n                  })),\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async createNote(args: any) {\n    try {\n      const { title, content, tags, isArchived = false, isPinned = false } = args;\n\n      if (!title || title.trim().length === 0) {\n        throw new Error('Title is required and cannot be empty');\n      }\n\n      const result = await this.bearService.createNote({\n        title: title.trim(),\n        content: content || '',\n        tags: tags || [],\n        isArchived,\n        isPinned,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  noteId: result.noteId,\n                  title: title.trim(),\n                  message: `Note created successfully with ID ${result.noteId}`,\n                  tagWarnings: result.tagWarnings,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async updateNote(args: any) {\n    try {\n      const { noteId, title, content, tags, isArchived, isPinned, expectedModificationDate } = args;\n\n      if (!noteId || typeof noteId !== 'number') {\n        throw new Error('Valid noteId is required');\n      }\n\n      const options: any = {};\n      if (title !== undefined) {\n        options.title = title;\n      }\n      if (content !== undefined) {\n        options.content = content;\n      }\n      if (tags !== undefined) {\n        options.tags = tags;\n      }\n      if (isArchived !== undefined) {\n        options.isArchived = isArchived;\n      }\n      if (isPinned !== undefined) {\n        options.isPinned = isPinned;\n      }\n      if (expectedModificationDate) {\n        options.expectedModificationDate = new Date(expectedModificationDate);\n      }\n\n      const result = await this.bearService.updateNote(noteId, options);\n\n      if (result.conflictDetected) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(\n                {\n                  success: false,\n                  error: 'Conflict detected: Note was modified by another process',\n                  conflictDetected: true,\n                },\n                null,\n                2\n              ),\n            },\n          ],\n        };\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  noteId,\n                  message: `Note ${noteId} updated successfully`,\n                  tagWarnings: result.tagWarnings,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async duplicateNote(args: any) {\n    try {\n      const { noteId, titleSuffix, copyTags = true } = args;\n\n      if (!noteId || typeof noteId !== 'number') {\n        throw new Error('Valid noteId is required');\n      }\n\n      const result = await this.bearService.duplicateNote(noteId, {\n        titleSuffix,\n        copyTags,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  originalNoteId: noteId,\n                  newNoteId: result.newNoteId,\n                  message: `Note ${noteId} duplicated successfully as note ${result.newNoteId}`,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async archiveNote(args: any) {\n    try {\n      const { noteId, archived } = args;\n\n      if (!noteId || typeof noteId !== 'number') {\n        throw new Error('Valid noteId is required');\n      }\n\n      if (typeof archived !== 'boolean') {\n        throw new Error('archived parameter must be a boolean');\n      }\n\n      const result = await this.bearService.archiveNote(noteId, archived);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  noteId,\n                  archived,\n                  message: `Note ${noteId} ${archived ? 'archived' : 'unarchived'} successfully`,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async triggerHashtagParsing(args: any) {\n    try {\n      const { note_id, note_title } = args;\n\n      if (!note_id && !note_title) {\n        throw new Error('Either note_id or note_title is required');\n      }\n\n      const result = await this.bearService.triggerHashtagParsing(note_id, note_title);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  message: result,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  private async batchTriggerHashtagParsing(args: any) {\n    try {\n      const { tag_filter, title_pattern, limit = 10, created_after } = args;\n\n      const result = await this.bearService.batchTriggerHashtagParsing({\n        tag_filter,\n        title_pattern,\n        limit,\n        created_after,\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: true,\n                data: {\n                  message: result,\n                },\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(\n              {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    }\n  }\n\n  async run(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    // Server running on stdio (no console output to avoid JSON-RPC interference)\n  }\n}\n\n// Start the server\nconst server = new BearMCPServer();\nserver.run().catch(error => {\n  // Silent error handling to avoid JSON-RPC interference\n  process.exit(1);\n});\n"],
  "mappings": "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AM,SACN,WAAY,CACV,GAAI,CACF,KAAM,SACN,YAAa,6BACf,CACF,EACA,SAAU,CAAC,IAAI,CACjB,CACF,EACA,CACE,KAAM,oBACN,YAAa,mCACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,MAAO,CACL,KAAM,SACN,YAAa,6BACf,CACF,EACA,SAAU,CAAC,OAAO,CACpB,CACF,EACA,CACE,KAAM,eACN,YAAa,uCACb,YAAa,CACX,KAAM,SACN,WAAY,CAAC,EACb,SAAU,CAAC,CACb,CACF,EACA,CACE,KAAM,mBACN,YAAa,yCACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,IAAK,CACH,KAAM,SACN,YAAa,4BACf,CACF,EACA,SAAU,CAAC,KAAK,CAClB,CACF,EACA,CACE,KAAM,qBACN,YAAa,+DACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,MAAO,CACL,KAAM,SACN,YAAa,oCACf,EACA,KAAM,CACJ,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,uCACf,EACA,YAAa,CACX,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,8BACf,EACA,OAAQ,CACN,KAAM,SACN,KAAM,CAAC,UAAW,WAAY,QAAS,MAAM,EAC7C,YAAa,qBACf,EACA,UAAW,CACT,KAAM,SACN,KAAM,CAAC,MAAO,MAAM,EACpB,YAAa,YACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,4BACb,QAAS,EACT,QAAS,GACX,CACF,EACA,SAAU,CAAC,CACb,CACF,EACA,CACE,KAAM,0BACN,YAAa,sDACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,cAAe,CACb,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,4CACf,EACA,gBAAiB,CACf,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,8CACf,EACA,WAAY,CACV,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,uCACf,EACA,WAAY,CACV,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YAAa,qCACf,EACA,SAAU,CACR,KAAM,UACN,YAAa,yBACf,EACA,WAAY,CACV,KAAM,UACN,YAAa,2BACf,EACA,UAAW,CACT,KAAM,SACN,YAAa,wBACf,EACA,UAAW,CACT,KAAM,SACN,YAAa,wBACf,CACF,EACA,SAAU,CAAC,CACb,CACF,EACA,CACE,KAAM,qBACN,YAAa,yDACb,YAAa,CACX,KAAM,SACN,WAAY,CAAC,EACb,SAAU,CAAC,CACb,CACF,EACA,CACE,KAAM,oBACN,YAAa,4DACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,OAAQ,CACN,KAAM,SACN,YAAa,8CACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,4CACb,QAAS,EACT,QAAS,EACX,CACF,EACA,SAAU,CAAC,QAAQ,CACrB,CACF,EACA,CACE,KAAM,wBACN,YAAa,gEACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,MAAO,CACL,KAAM,SACN,YAAa,qBACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,4BACb,QAAS,EACT,QAAS,EACX,EACA,gBAAiB,CACf,KAAM,UACN,YAAa,yCACf,EACA,aAAc,CACZ,KAAM,QACN,MAAO,CAAE,KAAM,SAAU,KAAM,CAAC,QAAS,UAAW,MAAM,CAAE,EAC5D,YAAa,qBACf,EACA,WAAY,CACV,KAAM,UACN,YAAa,iCACf,EACA,cAAe,CACb,KAAM,UACN,YAAa,uBACf,CACF,EACA,SAAU,CAAC,OAAO,CACpB,CACF,EACA,CACE,KAAM,yBACN,YAAa,mDACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,aAAc,CACZ,KAAM,SACN,YAAa,sCACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,gCACb,QAAS,EACT,QAAS,EACX,CACF,EACA,SAAU,CAAC,cAAc,CAC3B,CACF,EACA,CACE,KAAM,qBACN,YAAa,0DACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,cAAe,CACb,KAAM,SACN,YAAa,gCACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,kCACb,QAAS,EACT,QAAS,EACX,EACA,cAAe,CACb,KAAM,SACN,YAAa,wCACb,QAAS,EACT,QAAS,CACX,EACA,cAAe,CACb,KAAM,SACN,YAAa,iCACf,CACF,EACA,SAAU,CAAC,eAAe,CAC5B,CACF,EACA,CACE,KAAM,qBACN,YAAa,yCACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,QAAS,CACP,KAAM,SACN,YAAa,4BACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,sDACf,EACA,SAAU,CACR,KAAM,SACN,KAAM,CAAC,QAAS,UAAW,MAAM,EACjC,YAAa,iCACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,4BACb,QAAS,EACT,QAAS,EACX,EACA,eAAgB,CACd,KAAM,UACN,YAAa,gCACf,CACF,EACA,SAAU,CAAC,SAAS,CACtB,CACF,EACA,CACE,KAAM,oBACN,YAAa,oDACb,YAAa,CACX,KAAM,SACN,WAAY,CAAC,CACf,CACF,EACA,CACE,KAAM,oBACN,YAAa,iDACb,YAAa,CACX,KAAM,SACN,WAAY,CAAC,CACf,CACF,EACA,CACE,KAAM,4BACN,YAAa,qDACb,YAAa,CACX,KAAM,SACN,WAAY,CAAC,CACf,CACF,EACA,CACE,KAAM,uBACN,YAAa,oCACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,QAAS,CACP,KAAM,SACN,YAAa,oCACf,EACA,OAAQ,CACN,KAAM,SACN,YAAa,8BACb,QAAS,EACT,QAAS,EACX,CACF,CACF,CACF,EACA,CACE,KAAM,uBACN,YAAa,gDACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,OAAQ,CACN,KAAM,SACN,YAAa,yCACf,EACA,SAAU,CACR,KAAM,SACN,YAAa,+CACf,EACA,gBAAiB,CACf,KAAM,UACN,YAAa,gCACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,0CACb,QAAS,EACT,QAAS,GACX,CACF,CACF,CACF,EACA,CACE,KAAM,wBACN,YAAa,6CACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,uBAAwB,CACtB,KAAM,UACN,YAAa,+CACf,EACA,oBAAqB,CACnB,KAAM,UACN,YAAa,6CACf,EACA,yBAA0B,CACxB,KAAM,UACN,YAAa,mDACf,CACF,CACF,CACF,EACA,CACE,KAAM,0BACN,YAAa,iDACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,eAAgB,CACd,KAAM,UACN,YAAa,uCACf,EACA,SAAU,CACR,KAAM,UACN,YAAa,0CACf,EACA,UAAW,CACT,KAAM,UACN,YAAa,kCACf,EACA,SAAU,CACR,KAAM,UACN,YAAa,sCACf,EACA,cAAe,CACb,KAAM,UACN,YAAa,uCACf,EACA,UAAW,CACT,KAAM,UACN,YAAa,kCACf,EACA,aAAc,CACZ,KAAM,SACN,YAAa,qBACb,QAAS,CACX,EACA,aAAc,CACZ,KAAM,SACN,YAAa,qBACb,QAAS,CACX,EACA,MAAO,CACL,KAAM,SACN,YAAa,4BACb,QAAS,EACT,QAAS,GACX,CACF,CACF,CACF,EACA,CACE,KAAM,cACN,YAAa,2EACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,MAAO,CACL,KAAM,SACN,YAAa,uBACf,EACA,QAAS,CACP,KAAM,SACN,YAAa,qCACf,EACA,KAAM,CACJ,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YACE,6LACJ,EACA,WAAY,CACV,KAAM,UACN,YAAa,qCACf,EACA,SAAU,CACR,KAAM,UACN,YAAa,mCACf,CACF,EACA,SAAU,CAAC,OAAO,CACpB,CACF,EACA,CACE,KAAM,cACN,YAAa,mDACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,OAAQ,CACN,KAAM,SACN,YAAa,0BACf,EACA,MAAO,CACL,KAAM,SACN,YAAa,wBACf,EACA,QAAS,CACP,KAAM,SACN,YAAa,0BACf,EACA,KAAM,CACJ,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,EACxB,YACE,qMACJ,EACA,WAAY,CACV,KAAM,UACN,YAAa,qCACf,EACA,SAAU,CACR,KAAM,UACN,YAAa,mCACf,CACF,EACA,SAAU,CAAC,QAAQ,CACrB,CACF,EACA,CACE,KAAM,iBACN,YAAa,kEACb,YAAa,CACX,KAAM,SACN,WAAY,CACV,OAAQ,CACN,KAAM,SACN,YAAa,6BACf,EACA,YAAa,CACX,KAAM,SACN,YAAa,iEACf,EAC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",
  "names": ["external_exports", "__export", "BRAND", "DIRTY", "EMPTY_PATH", "INVALID", "NEVER", "OK", "ParseStatus", "ZodType", "ZodAny", "ZodArray", "ZodBigInt", "ZodBoolean", "ZodBranded", "ZodCatch", "ZodDate", "ZodDefault", "ZodDiscriminatedUnion", "ZodEffects", "ZodEnum", "ZodError", "ZodFirstPartyTypeKind", "ZodFunction", "ZodIntersection", "ZodIssueCode", "ZodLazy", "ZodLiteral", "ZodMap", "ZodNaN", "ZodNativeEnum", "ZodNever", "ZodNull", "ZodNullable", "ZodNumber", "ZodObject", "ZodOptional", "ZodParsedType", "ZodPipeline", "ZodPromise", "ZodReadonly", "ZodRecord", "ZodSet", "ZodString", "ZodSymbol", "ZodTuple", "ZodUndefined", "ZodUnion", "ZodUnknown", "ZodVoid", "addIssueToContext", "anyType", "arrayType", "bigIntType", "booleanType", "coerce", "custom", "dateType", "datetimeRegex", "en_default", "discriminatedUnionType", "effectsType", "enumType", "functionType", "getErrorMap", "getParsedType", "instanceOfType", "intersectionType", "isAborted", "isAsync", "isDirty", "isValid", "late", "lazyType", "literalType", "makeIssue", "mapType", "nanType", "nativeEnumType", "neverType", "nullType", "nullableType", "numberType", "objectType", "objectUtil", "oboolean", "onumber", "optionalType", "ostring", "pipelineType", "preprocessType", "promiseType", "quotelessJson", "recordType", "setType", "setErrorMap", "strictObjectType", "stringType", "symbolType", "tupleType", "undefinedType", "unionType", "unknownType", "util", "voidType", "util", "_", "assertIs", "_arg", "assertNever", "_x", "items", "obj", "item", "validKeys", "k", "filtered", "e", "object", "keys", "key", "arr", "checker", "val", "joinValues", "array", "separator", "value", "objectUtil", "first", "second", "ZodParsedType", "getParsedType", "data", "ZodIssueCode", "util", "quotelessJson", "obj", "ZodError", "_ZodError", "issues", "sub", "subs", "actualProto", "_mapper", "mapper", "issue", "fieldErrors", "processError", "error", "curr", "i", "el", "value", "formErrors", "errorMap", "issue", "_ctx", "message", "ZodIssueCode", "ZodParsedType", "util", "en_default", "overrideErrorMap", "en_default", "setErrorMap", "map", "overrideErrorMap", "getErrorMap", "makeIssue", "params", "data", "path", "errorMaps", "issueData", "fullPath", "fullIssue", "errorMessage", "maps", "m", "map", "EMPTY_PATH", "addIssueToContext", "ctx", "overrideMap", "getErrorMap", "issue", "en_default", "x", "ParseStatus", "_ParseStatus", "status", "results", "arrayValue", "INVALID", "pairs", "syncPairs", "pair", "key", "value", "finalObject", "DIRTY", "OK", "isAborted", "isDirty", "isValid", "isAsync", "errorUtil", "message", "ParseInputLazyPath", "parent", "value", "path", "key", "handleResult", "ctx", "result", "isValid", "error", "ZodError", "processCreateParams", "params", "errorMap", "invalid_type_error", "required_error", "description", "iss", "message", "ZodType", "input", "getParsedType", "ParseStatus", "isAsync", "data", "err", "maybeAsyncResult", "check", "getIssueProperties", "val", "setError", "ZodIssueCode", "refinementData", "refinement", "ZodEffects", "ZodFirstPartyTypeKind", "def", "ZodOptional", "ZodNullable", "ZodArray", "ZodPromise", "option", "ZodUnion", "incoming", "ZodIntersection", "transform", "defaultValueFunc", "ZodDefault", "ZodBranded", "catchValueFunc", "ZodCatch", "This", "target", "ZodPipeline", "ZodReadonly", "cuidRegex", "cuid2Regex", "ulidRegex", "uuidRegex", "nanoidRegex", "jwtRegex", "durationRegex", "emailRegex", "_emojiRegex", "emojiRegex", "ipv4Regex", "ipv4CidrRegex", "ipv6Regex", "ipv6CidrRegex", "base64Regex", "base64urlRegex", "dateRegexSource", "dateRegex", "timeRegexSource", "args", "secondsRegexSource", "secondsQuantifier", "timeRegex", "datetimeRegex", "regex", "opts", "isValidIP", "ip", "version", "isValidJWT", "jwt", "alg", "header", "base64", "decoded", "isValidCidr", "ZodString", "_ZodString", "ZodParsedType", "addIssueToContext", "INVALID", "status", "tooBig", "tooSmall", "util", "validation", "errorUtil", "options", "minLength", "maxLength", "len", "ch", "min", "max", "floatSafeRemainder", "step", "valDecCount", "stepDecCount", "decCount", "valInt", "stepInt", "ZodNumber", "_ZodNumber", "kind", "inclusive", "ZodBigInt", "_ZodBigInt", "ZodBoolean", "OK", "ZodDate", "_ZodDate", "minDate", "maxDate", "ZodSymbol", "ZodUndefined", "ZodNull", "ZodAny", "ZodUnknown", "ZodNever", "ZodVoid", "_ZodArray", "item", "i", "schema", "deepPartialify", "ZodObject", "newShape", "fieldSchema", "ZodTuple", "_ZodObject", "shape", "keys", "shapeKeys", "extraKeys", "pairs", "keyValidator", "unknownKeys", "catchall", "syncPairs", "pair", "issue", "defaultError", "augmentation", "merging", "index", "mask", "newField", "createZodEnum", "handleResults", "results", "unionErrors", "childCtx", "dirty", "issues", "types", "getDiscriminator", "type", "ZodLazy", "ZodLiteral", "ZodEnum", "ZodNativeEnum", "ZodDiscriminatedUnion", "_ZodDiscriminatedUnion", "discriminator", "discriminatorValue", "optionsMap", "discriminatorValues", "mergeValues", "a", "b", "aType", "bType", "bKeys", "sharedKeys", "newObj", "sharedValue", "newArray", "itemA", "itemB", "handleParsed", "parsedLeft", "parsedRight", "isAborted", "merged", "isDirty", "left", "right", "_ZodTuple", "items", "itemIndex", "x", "rest", "schemas", "ZodRecord", "_ZodRecord", "keyType", "valueType", "first", "second", "third", "ZodMap", "finalMap", "ZodSet", "_ZodSet", "finalizeSet", "elements", "parsedSet", "element", "minSize", "maxSize", "size", "ZodFunction", "_ZodFunction", "makeArgsIssue", "makeIssue", "getErrorMap", "en_default", "makeReturnsIssue", "returns", "fn", "me", "parsedArgs", "e", "parsedReturns", "returnType", "func", "getter", "values", "_ZodEnum", "expectedValues", "enumValues", "newDef", "opt", "nativeEnumValues", "promisified", "effect", "checkCtx", "arg", "processed", "DIRTY", "executeRefinement", "acc", "inner", "base", "preprocess", "ZodOptional", "ZodType", "input", "ZodParsedType", "OK", "type", "params", "ZodFirstPartyTypeKind", "processCreateParams", "ZodNullable", "ZodDefault", "ctx", "data", "ZodCatch", "newCtx", "result", "isAsync", "ZodError", "ZodNaN", "addIssueToContext", "ZodIssueCode", "INVALID", "BRAND", "ZodBranded", "ZodPipeline", "_ZodPipeline", "status", "inResult", "DIRTY", "a", "b", "ZodReadonly", "freeze", "isValid", "cleanParams", "p", "custom", "check", "_params", "fatal", "ZodAny", "r", "_fatal", "late", "ZodObject", "ZodFirstPartyTypeKind", "instanceOfType", "cls", "params", "custom", "data", "stringType", "ZodString", "numberType", "ZodNumber", "nanType", "ZodNaN", "bigIntType", "ZodBigInt", "booleanType", "ZodBoolean", "dateType", "ZodDate", "symbolType", "ZodSymbol", "undefinedType", "ZodUndefined", "nullType", "ZodNull", "anyType", "ZodAny", "unknownType", "ZodUnknown", "neverType", "ZodNever", "voidType", "ZodVoid", "arrayType", "ZodArray", "objectType", "ZodObject", "strictObjectType", "unionType", "ZodUnion", "discriminatedUnionType", "ZodDiscriminatedUnion", "intersectionType", "ZodIntersection", "tupleType", "ZodTuple", "recordType", "ZodRecord", "mapType", "ZodMap", "setType", "ZodSet", "functionType", "ZodFunction", "lazyType", "ZodLazy", "literalType", "ZodLiteral", "enumType", "ZodEnum", "nativeEnumType", "ZodNativeEnum", "promiseType", "ZodPromise", "effectsType", "ZodEffects", "optionalType", "ZodOptional", "nullableType", "ZodNullable", "preprocessType", "pipelineType", "ZodPipeline", "ostring", "onumber", "oboolean", "coerce", "arg", "NEVER", "INVALID", "LATEST_PROTOCOL_VERSION", "SUPPORTED_PROTOCOL_VERSIONS", "JSONRPC_VERSION", "ProgressTokenSchema", "external_exports", "CursorSchema", "BaseRequestParamsSchema", "RequestSchema", "NotificationSchema", "ResultSchema", "RequestIdSchema", "JSONRPCRequestSchema", "JSONRPCNotificationSchema", "JSONRPCResponseSchema", "ErrorCode", "JSONRPCErrorSchema", "JSONRPCMessageSchema", "EmptyResultSchema", "ImplementationSchema", "ClientCapabilitiesSchema", "InitializeRequestSchema", "ServerCapabilitiesSchema", "InitializeResultSchema", "InitializedNotificationSchema", "PingRequestSchema", "ProgressSchema", "ProgressNotificationSchema", "PaginatedRequestSchema", "PaginatedResultSchema", "ResourceContentsSchema", "TextResourceContentsSchema", "BlobResourceContentsSchema", "ResourceSchema", "ResourceTemplateSchema", "ListResourcesRequestSchema", "ListResourcesResultSchema", "ListResourceTemplatesRequestSchema", "ListResourceTemplatesResultSchema", "ReadResourceRequestSchema", "ReadResourceResultSchema", "ResourceListChangedNotificationSchema", "SubscribeRequestSchema", "UnsubscribeRequestSchema", "ResourceUpdatedNotificationSchema", "PromptArgumentSchema", "PromptSchema", "ListPromptsRequestSchema", "ListPromptsResultSchema", "GetPromptRequestSchema", "TextContentSchema", "ImageContentSchema", "EmbeddedResourceSchema", "PromptMessageSchema", "GetPromptResultSchema", "PromptListChangedNotificationSchema", "ToolSchema", "ListToolsRequestSchema", "ListToolsResultSchema", "CallToolResultSchema", "CompatibilityCallToolResultSchema", "CallToolRequestSchema", "ToolListChangedNotificationSchema", "LoggingLevelSchema", "SetLevelRequestSchema", "LoggingMessageNotificationSchema", "ModelHintSchema", "ModelPreferencesSchema", "SamplingMessageSchema", "CreateMessageRequestSchema", "CreateMessageResultSchema", "ResourceReferenceSchema", "PromptReferenceSchema", "CompleteRequestSchema", "CompleteResultSchema", "RootSchema", "ListRootsRequestSchema", "ListRootsResultSchema", "RootsListChangedNotificationSchema", "ClientRequestSchema", "ClientNotificationSchema", "ClientResultSchema", "ServerRequestSchema", "ServerNotificationSchema", "ServerResultSchema", "McpError", "code", "message", "data", "Protocol", "ProgressNotificationSchema", "notification", "PingRequestSchema", "_request", "transport", "error", "message", "responseHandlers", "_a", "McpError", "ErrorCode", "handler", "request", "_b", "result", "progress", "total", "progressToken", "response", "messageId", "resultSchema", "onprogress", "resolve", "reject", "jsonrpcRequest", "jsonrpcNotification", "requestSchema", "method", "notificationSchema", "Server", "Protocol", "_serverInfo", "InitializeRequestSchema", "request", "InitializedNotificationSchema", "_a", "requestedVersion", "SUPPORTED_PROTOCOL_VERSIONS", "LATEST_PROTOCOL_VERSION", "ListPromptsRequestSchema", "ListResourcesRequestSchema", "ListToolsRequestSchema", "SetLevelRequestSchema", "EmptyResultSchema", "params", "onprogress", "CreateMessageResultSchema", "ListRootsResultSchema", "import_node_process", "ReadBuffer", "chunk", "index", "line", "deserializeMessage", "JSONRPCMessageSchema", "serializeMessage", "message", "StdioServerTransport", "_stdin", "process", "_stdout", "ReadBuffer", "chunk", "error", "_a", "message", "_b", "resolve", "json", "serializeMessage", "import_sqlite3", "import_util", "import_promises", "import_child_process", "import_path", "import_os", "BearDatabaseError", "message", "code", "BearSafetyError", "execAsync", "BearDatabase", "dbPath", "path", "os", "stdout", "BearDatabaseError", "error", "timestamp", "backupPath", "stats", "requireWriteAccess", "BearSafetyError", "readOnly", "resolve", "reject", "mode", "sqlite3", "err", "sql", "params", "rows", "row", "operations", "result", "CoreDataUtils", "coreDataTimestamp", "date", "BearService", "dbPath", "BearDatabase", "totalNotes", "activeNotes", "trashedNotes", "archivedNotes", "encryptedNotes", "totalTags", "totalAttachments", "stats", "options", "sql", "params", "searchTerm", "CoreDataUtils", "row", "id", "title", "query", "tagName", "limit", "tagConditions", "tag", "excludeConditions", "sortBy", "sortOrder", "criteria", "titleConditions", "term", "contentConditions", "allTagConditions", "anyTagConditions", "havingClause", "totalStats", "longestNote", "shortestNote", "mostRecentNote", "oldestNote", "contentStats", "monthlyStats", "topTags", "stat", "noteId", "sourceNote", "relatedByTags", "contentKeywords", "relatedByContent", "kw", "text", "commonWords", "word", "searchTerms", "searchFields", "searchConditions", "note", "analysis", "a", "b", "partialQuery", "termSuggestions", "titleSuggestions", "tagSuggestions", "s", "referenceText", "referenceKeywords", "keywordConditions", "keyword", "noteKeywords", "commonKeywords", "nkw", "similarityScore", "result", "fuzzyMatch", "terms", "fuzzyTerms", "content", "titleMatches", "contentMatches", "matchedTerms", "snippets", "termLower", "titleMatchCount", "contentMatchCount", "matchIndex", "start", "end", "snippet", "relevanceScore", "queryLower", "tagMatches", "files", "typeStats", "attachments", "file", "filename", "extension", "contentType", "fileType", "overview", "lengthDistribution", "creationPatterns", "modificationPatterns", "notes", "contentAnalysis", "n", "linkAnalysis", "structureAnalysis", "wordCount", "linkCount", "imageCount", "todoCount", "codeBlockCount", "tableCount", "texts", "languageMap", "patternCounts", "block", "match", "lang", "language", "count", "p", "domainMap", "typeMap", "url", "domain", "internalLinks", "type", "titlePatternMap", "totalWords", "totalParagraphs", "pattern", "entry", "words", "paragraphs", "data", "patterns", "tagValidation", "sanitizedTags", "tagWarnings", "exec", "promisify", "execAsync", "noteContent", "titleHeaderPattern", "encodedTitle", "encodedContent", "encodedTags", "bearURL", "resolve", "error", "currentNote", "currentModDate", "titleToCheck", "encodedId", "tags", "t", "newTitle", "archived", "c", "r", "originalContent", "tempContent", "now", "sanitized", "warnings", "originalTag", "trimmed", "sanitizedTag", "hadChanges", "noteUUID", "noteTitle", "processedContent", "hashtagsLine", "bearContent", "date", "successCount", "fullNote", "BearMCPServer", "Server", "BearService", "ListToolsRequestSchema", "CallToolRequestSchema", "request", "name", "args", "error", "stats", "integrity", "table", "isRunning", "limit", "notes", "notesList", "note", "preview", "tags", "query", "id", "content", "title", "tagsList", "tag", "otherTags", "t", "tagInfo", "options", "length", "criteria", "status", "statusStr", "analytics", "monthlyData", "stat", "topTagsData", "noteId", "related", "result", "includeSnippets", "searchFields", "fuzzyMatch", "caseSensitive", "results", "partialQuery", "suggestions", "referenceText", "minSimilarity", "excludeNoteId", "fileType", "includeMetadata", "attachments", "includeContentAnalysis", "includeLinkAnalysis", "includeStructureAnalysis", "analysis", "isArchived", "isPinned", "expectedModificationDate", "titleSuffix", "copyTags", "archived", "note_id", "note_title", "tag_filter", "title_pattern", "created_after", "transport", "StdioServerTransport", "server"]
}
